<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>CPyton Emscripten Test</title>

<script src="spawn.js"></script>
<script src="codemirror/codemirror.js"></script>
<link rel="stylesheet" href="codemirror/codemirror.css">
<script src="codemirror/python.js"></script>

<style>
#busy {
    position: absolute;
}
.input.CodeMirror {
    border: 2px solid #888;
    height: auto;
}
.output.CodeMirror {
    background-color: #fffcfa;
    border: 2px solid #888;
    height: auto;
}
.evaloutput.CodeMirror {
    background-color: #fafcff;
    border: 2px solid #888;
    height: auto;
}
.stderr {
    background-color: #f00;
}
</style>

</head>
<body>

<div id='busy'><p>BUSY</p></div>
<div id='loading'><p>LOADING</p></div>

<textarea id='inputarea' class='input'></textarea>
<textarea id='outputarea' class='output'></textarea>
<textarea id='evaloutputarea' class='evaloutput'></textarea>


<script>

function onready(f) {
    if (window.onload) {
        var curronload = window.onload;
        var newonload = function(evt) {
            curronload(evt);
            f(evt);
        };
        window.onload = newonload;
    } else {
        window.onload = f;
    }
}

function newWorker() {
    var sharedBuffer = new SharedArrayBuffer(32*4);
    var spawn_data = {
      setup: function() {
        // Emscripten asm.js file needs to load data file
        // Inside Web Worker the url needs to be absolute
        if (typeof(Module) === "undefined") Module = {};

        if (typeof(Notebook) === "undefined") Notebook = {};

//**********************************************************************
// Monkey patch by replacing code for FS.createLazyFile
//**********************************************************************
        // Creates a file record for lazy-loading from a URL. XXX This requires a synchronous
        // XHR, which is not possible in browsers except in a web worker! Use preloading,
        // either --preload-file in emcc or FS.createPreloadedFile
        var myCreateLazyFile = function(parent, name, url, canRead, canWrite) {

          // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = []; // Loaded chunks. Index is the chunk number
          }
          LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = (idx / this.chunkSize)|0;
            return this.getter(chunkNum)[chunkOffset];
          }
          LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          }
          LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            // Find length
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024*64; // Chunk size in bytes

            if (!hasByteServing) chunkSize = datalength;

            // Function to get a range from the remote URL.
            var doXHR = (function(from, to) {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");

//********************** NEW
              send({ type: 'filesystem', data: {parent:parent, name:name, url:url, from:from, to:to}});
//********************** END NEW

              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);

              // Some hints to the browser that we want binary data.
              if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }

              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              if (xhr.response !== undefined) {
                return new Uint8Array(xhr.response || []);
              } else {
                return intArrayFromString(xhr.responseText || '', true);
              }
            });
            var lazyArray = this;
            lazyArray.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum+1) * chunkSize - 1; // including this byte
              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
              if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
              return lazyArray.chunks[chunkNum];
            });

            if (usesGzip || !datalength) {
              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
              datalength = this.getter(0).length;
              chunkSize = datalength;
              console.log("LazyFiles on gzip forces download of the whole file when length is accessed");
            }

            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          if (typeof XMLHttpRequest !== 'undefined') {
            if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, {
              length: {
                get: function() {
                  if(!this.lengthKnown) {
                    this.cacheLength();
                  }
                  return this._length;
                }
              },
              chunkSize: {
                get: function() {
                  if(!this.lengthKnown) {
                    this.cacheLength();
                  }
                  return this._chunkSize;
                }
              }
            });

            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url: url };
          }

          var node = FS.createFile(parent, name, properties, canRead, canWrite);
          // This is a total hack, but I want to get this lazy file code out of the
          // core of MEMFS. If we want to keep this lazy file concept I feel it should
          // be its own thin LAZYFS proxying calls to MEMFS.
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          // Add a function that defers querying the file size until it is asked the first time.
          Object.defineProperties(node, {
            usedBytes: {
              get: function() { return this.contents.length; }
            }
          });
          // override each stream op with one that tries to force load the lazy file first
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach(function(key) {
            var fn = node.stream_ops[key];
            stream_ops[key] = function forceLoadLazyFile() {
              if (!FS.forceLoadFile(node)) {
                throw new FS.ErrnoError(5);
              }
              return fn.apply(null, arguments);
            };
          });
          // use a custom read function
          stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(5);
            }
            var contents = stream.node.contents;
            if (position >= contents.length)
              return 0;
            var size = Math.min(contents.length - position, length);
            assert(size >= 0);
            if (contents.slice) { // normal array
              for (var i = 0; i < size; i++) {
                buffer[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
                buffer[offset + i] = contents.get(position + i);
              }
            }
            return size;
          };
          node.stream_ops = stream_ops;
          return node;
        };
//**********************************************************************
// End monkey patch section
//**********************************************************************

        Module.locateFile = function(path, prefix) {
            return config.absurl + '/' + path;
        };
        Module["preInit"] = function() {
            FS.mkdir('/lib');
            FS.mkdir('/lib/python3.7');
            myCreateLazyFile('/lib/python3.7', 'localroot.zip', config.absurl + '/localroot.zip', true, false);
            myCreateLazyFile('/lib/python3.7', 'python3.7.zip', config.absurl + '/python3.7.zip', true, false);
        };
        Module['print'] = function(text) {
            if (Notebook.ready) {
                send({ type:'stdout', data: text });
            } else {
                // Pre-ready messages go to console
                console.log(text);
            }
        };
        Module['printErr'] = function(text) {
            if (Notebook.ready) {
                send({ type:'stderr', data: text });
            } else {
                // Pre-ready messages go to console
                if (text.indexOf('Calling stub instead of') === 0) {
                    // Filter out these warnings related to signals
                    return;
                }
                console.warn(text);
            }
        };
        importScripts(config.absurl + '/python.asm.js');
        Kernel_new = Module.cwrap('Kernel_new', 'number', []);
        Kernel_delete = Module.cwrap('Kernel_delete', null, ['number']);
        Kernel_eval = Module.cwrap('Kernel_eval', 'number', ['number', 'string']);
        Kernel_version = Module.cwrap('Kernel_version', 'string', []);
        Result_str = Module.cwrap('Result_str', 'number', ['number']);
        Result_delete = Module.cwrap('Result_delete', null, ['number']);
        sharedArray = new Int32Array(config.shared);

        keyboardInterrupt = function() {
            if (sharedArray[0] === 1) {
                sharedArray[0] = 0;
                return true;
            }
            return false;
        };

        // Wait for the module to be ready before calling any functions.
        var interval = setInterval(function () {
            if (Module.calledRun) {
                clearInterval(interval);
                kernel = Kernel_new();
                Notebook.ready = true;
                // Clear busy
                sharedArray[1] = 0;
                var result_str = Kernel_version();
//                var result_repr = UTF8ToString(result_str);
                send({ type:'ready', data:result_str });
            }
        }, 100);
      },
      fn: function(input, done) {
        if (input.type === 'execute') {
            if (!Module.calledRun) {
                done({ type:'notready' });
            } else {
                var result = Kernel_eval(kernel, input.data);
                var result_str = Result_str(result);
                var result_repr = UTF8ToString(result_str);
                done({ type: 'response', data: result_repr });
                Result_delete(result);
            }
        } else {
            throw 'Unknown message type in webworker onmessage';
        }
      },
      config: {
          absurl: document.location.protocol + '//' + document.location.host,
          shared: sharedBuffer
      }
    };

    var worker = spawn(spawn_data);
    worker.sharedBuffer = sharedBuffer;
    worker.sharedArray = new Int32Array(sharedBuffer);
    // Set busy, will clear once worker is ready
    worker.sharedArray[1] = 1;
    return worker;
}

function setupCallbacks(worker, outputarea, evaloutputarea) {
    worker.on('message', function(msg) {
        if (msg.type === 'ready') {
            console.log('CPython-Emscripten Ready - ' + msg.data);
        } else if (msg.type === 'stdout') {
            outputarea.replaceRange(msg.data + '\n', CodeMirror.Pos(outputarea.lastLine()));
        } else if (msg.type === 'stderr') {
            outputarea.replaceRange(msg.data + '\n', CodeMirror.Pos(outputarea.lastLine()));
            // Color it yellow?
        } else if (msg.type === 'response') {
            evaloutputarea.setValue(msg.data);
        } else if (msg.type === 'filesystem') {
            var elem = document.getElementById('loading');
            elem.style.visibility = 'visible';
            setTimeout(function() {
                elem.style.visibility = 'hidden';
            }, 200);
            //console.log('File access: ' + msg.data.url + ':' + msg.data.from + '-' + msg.data.to);
        } else {
            console.log('Unknown response in main thread onmessage', msg);
            throw 'Unknown response in main thread onmessage';
        }
    });
}

onready(function() {

    var worker = newWorker();

    var inputarea = CodeMirror.fromTextArea(document.getElementById('inputarea'));
    var outputarea = CodeMirror.fromTextArea(document.getElementById('outputarea'));
    var evaloutputarea = CodeMirror.fromTextArea(document.getElementById('evaloutputarea'));
    
    inputarea.getWrapperElement().classList.add('input');
    outputarea.getWrapperElement().classList.add('output');
    evaloutputarea.getWrapperElement().classList.add('evaloutput');

    inputarea.setOption('extraKeys', {
        'Ctrl-Enter': function(cm) {
            // Clear flag to indicate keyboard interrupt
            worker.sharedArray[0] = 0;
            worker.send({ type:'execute', data:inputarea.doc.getValue() });
            outputarea.setValue("");
            evaloutputarea.setValue("");
        },
        'Ctrl-Q': function(cm) {
            worker.terminate();
            worker = newWorker();
            setupCallbacks(worker, outputarea, evaloutputarea);
        },
        'Ctrl-C': function(cm) {
            // Set flag to indicate keyboard interrupt
            worker.sharedArray[0] = 1;
        }
    });

    outputarea.setOption('readOnly', 'nocursor');
    outputarea.setOption('lineWrapping', true);
    evaloutputarea.setOption('readOnly', 'nocursor');
    evaloutputarea.setOption('lineWrapping', true);

    setupCallbacks(worker, outputarea, evaloutputarea);
    
    setInterval(function() {
        var elem = document.getElementById('busy');
        if (worker.sharedArray[1] === 0) {
            elem.style.visibility = 'hidden';
        } else {
            elem.style.visibility = 'visible';
        }
    }, 500);

    window.sharedArray = worker.sharedArray;
    window.inputarea = inputarea;
});

</script>

</body>
</html>
