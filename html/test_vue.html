<!DOCTYPE html>
<html>
<head>
<title>Test of VueJS Notebook</title>
<script defer src="spawn.js"></script>
<script defer src="codemirror/codemirror.js"></script>
<link rel="stylesheet" href="codemirror/codemirror.css">
<script defer src="codemirror/python.js"></script>
<script defer src="vue.js"></script>
<script defer src="vuex.js"></script>
<script src="//cdn.jsdelivr.net/npm/sortablejs@1.8.4/Sortable.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Vue.Draggable/2.19.2/vuedraggable.umd.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
<script defer src="https://use.fontawesome.com/releases/v5.7.2/js/all.js" integrity="sha384-0pzryjIRos8mFBWMzSSZApWtPl/5++eIfzYmTgBBmXYdhvxPc+XcFEk+zJwDgWbP" crossorigin="anonymous"></script>

<style>
#status {
    display: flex;
    width: 100%;
    height: 32px;
    margin: 10px;
}
div#status p {
    padding: 0;
    margin: 0;
    font-size: 10pt;
    font-family: monospace;
}
.cell {
    position: relative;
    border: 1px solid #000;
    margin: 5px;
}
div .side {
    width: 40px;
    background-color: #f00;
    min-height: 40px;
}

.input {
    height: auto;
}
.input.CodeMirror {
    background-color: #fafcff;
    border: 1px solid #f0f4ff;
    border-radius: 4px;
    height: auto;
    z-index: 10;
}
.CodeMirror-scroll {
    width: 100%;
}

.output {
    background-color: #fffcfa;
    border: 2px solid #888;
    height: auto;
    margin-left: 40px;
}
.evaloutput {
    background-color: #fafcff;
    border: 2px solid #888;
    height: auto;
}
.stdout {
}
.stderr {
    background-color: #ff0;
}
.eval {
}
.cssdrag {
    position: relative;
    border: 2px solid;
    margin: 5px;
    padding: 5px;
    background-color: #fff;
}
.handle {
    position: absolute;
    top: 1px;
    right: 1px;
    z-index: 20;
}
.output pre {
    white-space: pre-wrap;
    word-break: break-all;
    margin: 0;
    padding: 1px 24px 1px 24px;
}
.led {
    width: 16px;
    height: 16px;
    background-image: url('gfx/led-sprite-small.png');
    background-position: 0px -128px;
}
.led.on {
    background-position: 0px -144px;
}
</style>
</head>
<body>




<div id="app">

    <div id='status'>
        <div id='busy' class='led'></div>
        <div id='loading' class='led'></div>
        <div id='starting' class='led'></div>
    </div>
    <cells
        v-on:update:value="handleInput"
        v-on:update:values="handleDrag"
        v-on:action="handleAction"
        v-bind:values="getCells()"
    >
    </cells>
    <pre>{{ JSON.stringify(notebook, null, 2) }}</pre>
</div>

<script>

function onready(f) {
    if (window.onload) {
        var curronload = window.onload;
        var newonload = function(evt) {
            curronload(evt);
            f(evt);
        };
        window.onload = newonload;
    } else {
        window.onload = f;
    }
}

onready(function() {

    // Global variable keeping list of all codemirror editors
    // Needed to quickly update dragdrop state
    Vue.prototype.$globalCMList = [];

    Vue.component('codemirror', {
        props: ['options', 'value', 'id'],
        template: String.raw`
            <div class="input">
                <textarea></textarea>
            </div>`,
        mounted: function() {
            var self = this;
            var elem = self.$el.querySelector('textarea');
            self.editor = CodeMirror.fromTextArea(elem, self.options);
            self.$globalCMList.push(self.editor);
            self.editor.getWrapperElement().classList.add('input');
            self.editor.setValue(self.value || '');
            self.editor.on('change', function(cm) {
                self.$emit('update:value', cm.getValue());
            });
            self.editor.setOption('extraKeys', {
                'Ctrl-Enter': function(cm) {
                    self.$emit('action', { id:self.id, action:'eval' });
                },
                'Ctrl-C': function(cm) {
                    self.$emit('action', { id:self.id, action:'break' });
                },
                'Ctrl-I': function(cm) {
                    self.$emit('action', { id:self.id, action:'insert-after' });
                },
            });
        },
        watch: {
            value: function(v) {
                var currentValue = this.editor.getValue();
                if (currentValue !== v) {
                    this.editor.setValue(v);
                }
            },
        },
    });

    Vue.component('celloutput', {
        props: ['values'],
        template: String.raw`
            <div class="output">
                <pre v-for="value in values" :class="value.type">{{ value.contents }}</pre>
            </div>`
    });

    Vue.component('cell', {
        props: ['value', 'output', 'id'],
        template: String.raw`
            <div class="cell">
                <div class="side">
                </div>
                <codemirror
                    v-bind:value="value"
                    v-on:update:value="handleInput"
                    v-on:action="handleAction"
                    >
                </codemirror>
                <div class="handle">
                    <i class="fas fa-grip-vertical"></i>
                </div>
                <celloutput
                    v-bind:values="output"
                >
                </celloutput>
            </div>`,
        methods: {
            handleInput (event) {
                this.$emit('update:value', { id:this.id, value:event });
            },
            handleAction (event) {
                this.$emit('action', { id:this.id, action:event.action });
            },
        }
    });

    Vue.component('draggable', vuedraggable);

    Vue.component('cells', {
        props: [ 'values' ],
        template: String.raw`
            <div class="cells">
                <draggable
                    v-model='contents'
                    handle=".handle"
                    v-on:start="dragStart"
                    v-on:end="dragEnd"
                >
                    <cell
                        v-for="(content, index) in values"
                        v-bind:value="content.source"
                        v-bind:output="content.outputs"
                        v-bind:id="index"
                        v-bind:key="content.id"
                        v-on:update:value="handleInput"
                        v-on:action="handleAction"
                    >
                    </cell>
                </draggable>
            </div>`,
        computed: {
            contents: {
                get() {
                    return this.values;
                },
                set(values) {
                    this.$emit('update:values', values);
                }
            }
        },
        methods: {
            dragStart (event) {
                const cm = this.$globalCMList;
                for (var i = 0; i < cm.length; i++) {
                    cm[i].__oldDragDrop = cm[i].getOption('dragDrop');
                    cm[i].setOption('dragDrop', false);
                }
            },
            dragEnd (event) {
                const cm = this.$globalCMList;
                for (var i = 0; i < cm.length; i++) {
                    cm[i].setOption('dragDrop', cm[i].__oldDragDrop);
                }
            },
            handleInput (event) {
                this.$emit('update:value', event);
            },
            handleAction (event) {
                this.$emit('action', event);
            },
        }
    });

    const store = new Vuex.Store({
        state: {
            cells: [
                {
                    cell_type: 'code',
                    execution_count: 1,
                    source: '# some python code here\n2 + 2\n',
                    outputs: [],
                    id: 1234,
                },
                {
                    cell_type: 'code',
                    execution_count: 1,
                    source: '2 ** 10\n',
                    outputs: [],
                    id: 54330,
                }
            ],
        },
        mutations: {
            setSource (state, payload) {
                Vue.set(state.cells[payload.n], 'source', payload.source);
            },
            clearOutput (state, payload) {
                Vue.set(state.cells[payload.n], 'outputs', []);
            },
            addOutput (state, payload) {
                state.cells[payload.n].outputs.push(payload.out);
            },
            insertAfter (state, payload) {
                const newcell = {
                    cell_type: 'code',
                    execution_count: 1,
                    source: '',
                    outputs: [],
                };
                state.cells.splice(payload.n + 1, 0, newcell);
            },
            updateCells (state, payload) {
                state.cells = payload;
            },
            initialiseStore(state) {
                if (localStorage.getItem('store')) {
                    this.replaceState(
                        Object.assign(state, JSON.parse(localStorage.getItem('store')))
                    );
                }
            }
        }
    });

    // Subscribe to store updates
    store.subscribe(function (mutation, state) {
        localStorage.setItem('store', JSON.stringify(state));
    });

    var signalMap = {
        'interrupt':0,
        'busy':1,
        'loading':2,
        'starting':3,
    };

    var app = new Vue({
        el: '#app',
        store,
        data: {
            opts: { lineNumbers: true },
        },
        beforeCreate() {
            this.$store.commit('initialiseStore');
        },
        computed: {
            contents() {
                var notebook = this.$store.state;
                var cells = notebook.cells;
                var numCells = cells.length;
                var result = [];
                for (var i = 0; i < numCells; i++) {
                    var cell = cells[i];
                    result.push({ value:cell.source, output:cell.outputs, id:i });
                }
                return result;
            },
            notebook() {
                return this.$store.state;
            }
        },
        methods: {
            handleInput (event) {
                this.$store.commit('setSource', {n:event.id, source:event.value});
            },
            handleAction (event) {
                var action = event.action;
                if (action === 'eval') {
                    this.addOutput(event.id, { type:'stdout', contents:'42' });
                } else if (action === 'break') {
                    this.addOutput(event.id, { type:'stderr', contents:'Error in eval:\nTraceback\n  23\n  3524\n' });
                    } else if (action === 'insert-after') {
                    this.$store.commit('insertAfter', { n:event.id });
                } else {
                    console.log("Unknown action", action, event.id);
                }
            },
            handleDrag (event) {
                this.$store.commit('updateCells', event);
            },
            addOutput (n, out) {
                this.$store.commit('addOutput', {n, out});
            },
            getCells() {
                return this.$store.state.cells;
            },
        }
    });
    window.app = app;
    window.store = store;
});


</script>
</body>
</html>
