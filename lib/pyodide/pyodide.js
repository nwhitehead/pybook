!function(factory){"function"==typeof define&&define.amd?define(factory):factory()}((function(){"use strict";let baseURL,Module={};async function initializePackageIndex(indexURL){baseURL=indexURL;let response=await fetch(`${indexURL}packages.json`);Module.packages=await response.json()}Module.noImageDecoding=!0,Module.noAudioDecoding=!0,Module.noWasmDecoding=!1,Module.preloadedWasm={};const package_uri_regexp=/^.*?([^\/]*)\.js$/;function _uri_to_package_name(package_uri){let match=package_uri_regexp.exec(package_uri);if(match)return match[1]}let loadScript;if(self.document)loadScript=url=>import(url);else{if(!self.importScripts)throw new Error("Cannot determine runtime environment");loadScript=async url=>{self.importScripts(url)}}function recursiveDependencies(names,_messageCallback,errorCallback,sharedLibsOnly){const packages=Module.packages.dependencies,loadedPackages=Module.loadedPackages,sharedLibraries=Module.packages.shared_library,toLoad=new Map,addPackage=pkg=>{if(!toLoad.has(pkg)&&(toLoad.set(pkg,"default channel"),void 0===loadedPackages[pkg]))for(let dep of packages[pkg])addPackage(dep)};for(let name of names){const pkgname=_uri_to_package_name(name);if(void 0!==pkgname){if(toLoad.has(pkgname)&&toLoad.get(pkgname)!==name){errorCallback(`Loading same package ${pkgname} from ${name} and ${toLoad.get(pkgname)}`);continue}toLoad.set(pkgname,name)}else name in packages?addPackage(name):errorCallback(`Skipping unknown package '${name}'`)}if(sharedLibsOnly){let onlySharedLibs=new Map;for(let c of toLoad)c[0]in sharedLibraries&&onlySharedLibs.set(c[0],toLoad.get(c[0]));return onlySharedLibs}return toLoad}async function _loadPackage(names,messageCallback,errorCallback){let toLoad=recursiveDependencies(names,0,errorCallback);if(Module.locateFile=path=>{let pkg=path.replace(/\.data$/,"");if(toLoad.has(pkg)){let package_uri=toLoad.get(pkg);if("default channel"!=package_uri)return package_uri.replace(/\.js$/,".data")}return baseURL+path},0===toLoad.size)return Promise.resolve("No new packages to load");messageCallback(`Loading ${Array.from(toLoad.keys()).join(", ")}`);let scriptPromises=[];for(let[pkg,uri]of toLoad){let loaded=Module.loadedPackages[pkg];if(void 0!==loaded){if(loaded===uri||"default channel"===uri){messageCallback(`${pkg} already loaded from ${loaded}`);continue}errorCallback(`URI mismatch, attempting to load package ${pkg} from ${uri} while it is already loaded from ${loaded}. To override a dependency, load the custom package first.`);continue}let scriptSrc="default channel"===uri?`${baseURL}${pkg}.js`:uri;messageCallback(`Loading ${pkg} from ${scriptSrc}`),scriptPromises.push(loadScript(scriptSrc).catch((()=>{errorCallback(`Couldn't load package from URL ${scriptSrc}`),toLoad.delete(pkg)})))}try{await Promise.all(scriptPromises).then((function(){const promise=new Promise((r=>{Module.monitorRunDependencies=n=>{0===n&&r()}}));return Module.addRunDependency("dummy"),Module.removeRunDependency("dummy"),promise}))}finally{delete Module.monitorRunDependencies}let resolveMsg,packageList=[];for(let[pkg,uri]of toLoad)Module.loadedPackages[pkg]=uri,packageList.push(pkg);if(packageList.length>0){resolveMsg=`Loaded ${packageList.join(", ")}`}else resolveMsg="No packages loaded";Module.reportUndefinedSymbols(),messageCallback(resolveMsg),Module.runPythonSimple("import importlib\nimportlib.invalidate_caches()\n")}let _package_lock=Promise.resolve();Module.loadedPackages={},Module.loadPackage=async function(names,messageCallback,errorCallback){if(Module.isPyProxy(names)){let temp;try{temp=names.toJs()}finally{names.destroy()}names=temp}Array.isArray(names)||(names=[names]);let oldPlugin,sharedLibraryNames=[];try{let sharedLibraryPackagesToLoad=recursiveDependencies(names,0,errorCallback,!0);for(let pkg of sharedLibraryPackagesToLoad)sharedLibraryNames.push(pkg[0])}catch(e){}for(let p in Module.preloadPlugins)if(Module.preloadPlugins[p].canHandle("test.so")){oldPlugin=Module.preloadPlugins[p];break}var loadPluginOverride=new Proxy(oldPlugin,{get:function(obj,prop){return"handle"===prop?function(bytes,name){obj[prop].apply(obj,arguments),this.asyncWasmLoadPromise=this.asyncWasmLoadPromise.then((function(){Module.loadDynamicLibrary(name,{global:!0,nodelete:!0})}))}:obj[prop]}});Module.preloadPlugins.unshift(loadPluginOverride);let releaseLock=await async function(){let releaseLock,old_lock=_package_lock;return _package_lock=new Promise((resolve=>releaseLock=resolve)),await old_lock,releaseLock}();try{await _loadPackage(sharedLibraryNames,messageCallback||console.log,errorCallback||console.error),Module.preloadPlugins.shift(loadPluginOverride),await _loadPackage(names,messageCallback||console.log,errorCallback||console.error)}finally{releaseLock()}},Module.pyodide_py={},Module.globals={},Module.PythonError=class{constructor(){this.message}},Module.version="",Module.runPython=function(code,globals=Module.globals){return Module.pyodide_py.eval_code(code,globals)},Module.loadPackagesFromImports=async function(code,messageCallback,errorCallback){let imports=Module.pyodide_py.find_imports(code).toJs();if(0===imports.length)return;let packageNames=Module.packages.import_name_to_package_name,packages=new Set;for(let name of imports)name in packageNames&&packages.add(packageNames[name]);packages.size&&await Module.loadPackage(Array.from(packages.keys()),messageCallback,errorCallback)},Module.pyimport=name=>(console.warn("Access to the Python global namespace via pyodide.pyimport is deprecated and will be removed in version 0.18.0. Use pyodide.globals.get('key') instead."),Module.globals.get(name)),Module.runPythonAsync=async function(code){let coroutine=Module.pyodide_py.eval_code_async(code,Module.globals);try{return await coroutine}finally{coroutine.destroy()}},Module.registerJsModule=function(name,module){Module.pyodide_py.register_js_module(name,module)},Module.unregisterJsModule=function(name){Module.pyodide_py.unregister_js_module(name)},Module.toPy=function(obj,depth=-1){switch(typeof obj){case"string":case"number":case"boolean":case"bigint":case"undefined":return obj}if(!obj||Module.isPyProxy(obj))return obj;let obj_id=0,py_result=0,result=0;try{if(obj_id=Module.hiwire.new_value(obj),py_result=Module.__js2python_convert(obj_id,new Map,depth),0===py_result&&Module._pythonexc2js(),Module._JsProxy_Check(py_result))return obj;result=Module._python2js(py_result),0===result&&Module._pythonexc2js()}finally{Module.hiwire.decref(obj_id),Module._Py_DecRef(py_result)}return Module.hiwire.pop_value(result)},Module.isPyProxy=function(jsobj){return!!jsobj&&void 0!==jsobj.$$&&"PyProxy"===jsobj.$$.type};let PUBLIC_API=["globals","pyodide_py","version","loadPackage","loadPackagesFromImports","loadedPackages","isPyProxy","pyimport","runPython","runPythonAsync","registerJsModule","unregisterJsModule","setInterruptBuffer","toPy","PythonError"];Module.dump_traceback=function(){Module.__Py_DumpTraceback(1,Module._PyGILState_GetThisThreadState())};let fatal_error_occurred=!1;Module.fatal_error=function(e){if(fatal_error_occurred)return console.error("Recursive call to fatal_error. Inner error was:"),void console.error(e);fatal_error_occurred=!0,console.error("Pyodide has suffered a fatal error. Please report this to the Pyodide maintainers."),console.error("The cause of the fatal error was:"),console.error(e);try{Module.dump_traceback();for(let key of PUBLIC_API)"version"!==key&&Object.defineProperty(Module.public_api,key,{enumerable:!0,configurable:!0,get:()=>{throw new Error("Pyodide already fatally failed and can no longer be used.")}});Module.on_fatal&&Module.on_fatal(e)}catch(err2){console.error("Another error occurred while handling the fatal error:"),console.error(err2)}throw e},Module.runPythonSimple=function(code){let errcode,code_c_string=Module.stringToNewUTF8(code);try{errcode=Module._run_python_simple_inner(code_c_string)}catch(e){Module.fatal_error(e)}finally{Module._free(code_c_string)}-1===errcode&&Module._pythonexc2js()},globalThis.pyodide={},globalThis.loadPyodide=async function(config={}){if(config=Object.assign({fullStdLib:!0},config),loadPyodide.inProgress)throw globalThis.languagePluginURL?new Error("Pyodide is already loading because languagePluginURL is defined."):new Error("Pyodide is already loading.");if(loadPyodide.inProgress=!0,!config.indexURL)throw new Error("Please provide indexURL parameter to loadPyodide");let baseURL=config.indexURL;baseURL.endsWith(".js")&&(baseURL=baseURL.substr(0,baseURL.lastIndexOf("/"))),baseURL.endsWith("/")||(baseURL+="/");let packageIndexReady=initializePackageIndex(baseURL);Module.locateFile=path=>baseURL+path;let moduleLoaded=new Promise((r=>Module.postRun=r));const scriptSrc=`${baseURL}pyodide.asm.js`;await loadScript(scriptSrc),await _createPyodideModule(Module),await moduleLoaded,Module.runPythonSimple("\ndef temp(Module):\n  import pyodide\n  import __main__\n  import builtins\n\n  globals = __main__.__dict__\n  globals.update(builtins.__dict__)\n\n  Module.version = pyodide.__version__\n  Module.globals = globals\n  Module.builtins = builtins.__dict__\n  Module.pyodide_py = pyodide\n"),Module.saveState=()=>Module.pyodide_py._state.save_state(),Module.restoreState=state=>Module.pyodide_py._state.restore_state(state),Module.init_dict.get("temp")(Module),Module.globals=Module.wrapNamespace(Module.globals),function(){let depth=0;try{!function recurse(){depth+=1,recurse()}()}catch(err){}let recursionLimit=depth/60;recursionLimit>1e3&&(recursionLimit=1e3),Module.runPythonSimple(`import sys; sys.setrecursionlimit(int(${recursionLimit}))`)}();let pyodide=function(){let namespace={_module:Module};Module.public_api=namespace;for(let name of PUBLIC_API)namespace[name]=Module[name];return namespace}();return Module.registerJsModule("js",globalThis),Module.registerJsModule("pyodide_js",pyodide),globalThis.pyodide=pyodide,await packageIndexReady,config.fullStdLib&&await pyodide.loadPackage(["distutils"]),pyodide},globalThis.languagePluginUrl&&(console.warn("languagePluginUrl is deprecated and will be removed in version 0.18.0, instead use loadPyodide({ indexURL : <some_url>})"),globalThis.languagePluginLoader=loadPyodide({indexURL:globalThis.languagePluginUrl}))}));
//# sourceMappingURL=pyodide.js.map
