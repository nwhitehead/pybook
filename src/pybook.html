<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>PyBook Notebook</title>
<script defer src="../lib/codemirror/codemirror.js"></script>
<link rel="stylesheet" href="../lib/codemirror/codemirror.css">
<script defer src="../lib/codemirror/python.js"></script>
<script defer src="../lib/vue.js"></script>
<script defer src="../lib/vuex.js"></script>
<script defer src="../lib/marked.min.js"></script>
<script src="../lib/Sortable.min.js"></script>
<script src="../lib/vuedraggable.umd.min.js"></script>
<link rel="stylesheet" href="../lib/bulma.min.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">

<style>

div.status {
    display: inline-flex;
    width: auto;
    height: 32px;
    margin: 10px;
}
div.status p {
    padding: 0;
    margin: 0;
    font-size: 10pt;
    font-family: monospace;
}

#app {
    outline: none !important;
}
.cell {
    position: relative;
    border: 1px solid transparent;
    border-left-width: 5px;
    margin: 15px;
    display: flex;
}
.cell.selected {
    border: 1px solid #00f;
    border-left-width: 5px;
}
.cell.command {
    background: #ddd;
    border: 1px solid #080;
    border-left-width: 5px;
    border-right-width: 5px;
}
.side-left.working {
    background: #edf;
}

div .side-left {
    min-height: 40px;
    flex: 0 0 40px;
}
div .side-right {
    flex: 1 1 auto;
    overflow: hidden;
}
div.cellinput {
    height: auto;
    width: 100%;
    padding: 10px 8px 10px 10px;
}
div.cellinput.CodeMirror {
    border: 1px solid #f0f4ff;
    border-radius: 4px;
    height: auto;
    z-index: 10;
    width: 100%;
}
div.code div.cellinput.CodeMirror {
    background-color: #f6faff;
}   
div.markdown div.cellinput.CodeMirror {
    background-color: #fffaf6;
}
.cellinput.CodeMirror-focused {
}
.CodeMirror-scroll {
    width: auto;
}

.output {
    height: auto;
}
div.output pre {
    background-color: transparent;
}
.evaloutput {
    height: auto;
}
div.output pre.stdout {
}
div.output pre.stderr {
    background-color: #ff0;
}
.eval {
}
.output pre {
    white-space: pre-wrap;
    word-break: break-all;
    margin: 0;
    padding: 1px 24px 1px 24px;
}
.led {
    width: 16px;
    height: 16px;
    background-image: url('../gfx/led-sprite-small.png');
    background-position: 0px -128px;
}
.led.on {
    background-position: 0px -144px;
}
</style>
</head>
<body>




<div id="app" tabindex="0"
    v-on:click.stop="handleOuterClick"
    v-on:keyup.right.ctrl.exact="pageNext"
    v-on:keyup.left.ctrl.exact="pagePrevious"
    v-on:keyup.up.ctrl.exact="cellPrevious"
    v-on:keyup.down.ctrl.exact="cellNext"
    v-on:keyup.esc.exact="ifEdit(modeCommand)"
    v-on:keyup.enter.exact="ifCommand(modeEdit)"
    v-on:keyup.enter.ctrl.exact="eval"
    v-on:keyup.enter.shift.exact="evalNext"
    v-on:keyup.enter.alt.exact="evalNew"
    v-on:keyup.c.ctrl.exact='interrupt'
    v-on:keyup.k.ctrl.exact='terminate'
    v-on:keyup.i.ctrl.exact='insertCellAfter'
    v-on:keyup.up.exact='ifCommand(cellPrevious)'
    v-on:keyup.down.exact='ifCommand(cellNext)'
    v-on:keyup.a.exact='ifCommand(insertCellBefore)'
    v-on:keyup.b.exact='ifCommand(insertCellAfter)'
    v-on:keyup.d.exact='ifCommand(deleteCell)'
    v-on:keyup.y.exact='ifCommand(typeCellCode)'
    v-on:keyup.m.exact='ifCommand(typeCellMarkdownEdit)'
    v-on:keyup.m.shift.exact='ifCommand(typeCellMarkdownView)'
>

    <div id="menu">
        <div class="dropdown is-hoverable">
            <div class="dropdown-trigger">
                <button class="button" aria-haspopups="true" aria-controls="dropdown-menu-file">
                    <span>File</span>
                </button>
            </div>
            <div class="dropdown-menu" id="dropdown-menu-file" role="menu">
                <div class="dropdown-content">
                    <a class="dropdown-item" v-on:click.stop="fileNew">New</a>
                    <a class="dropdown-item" v-on:click.stop="fileSave">Save</a>
                </div>
            </div>
        </div>
        <div class="dropdown is-hoverable">
            <div class="dropdown-trigger">
                <button class="button" aria-haspopups="true" aria-controls="dropdown-menu-cell">
                    <span>Cell</span>
                </button>
            </div>
            <div class="dropdown-menu" id="dropdown-menu-cell" role="menu">
                <div class="dropdown-content">
                    <a class="dropdown-item" v-on:click.stop="insertCellBefore">Insert new cell before</a>
                    <a class="dropdown-item" v-on:click.stop="insertCellAfter">Insert new cell after</a>
                    <a class="dropdown-item" v-on:click.stop="deleteCell">Delete cell</a>
                    <a class="dropdown-divider"></a>
                    <a class="dropdown-item" v-on:click.stop="moveCellBefore">Move cell before</a>
                    <a class="dropdown-item" v-on:click.stop="moveCellAfter">Move cell after</a>
                    <a class="dropdown-divider"></a>
                    <a class="dropdown-item" v-on:click.stop="typeCellCode">Type - code</a>
                    <a class="dropdown-item" v-on:click.stop="typeCellMarkdownEdit">Type - Markdown - Edit</a>
                    <a class="dropdown-item" v-on:click.stop="typeCellMarkdownView">Type - Markdown - View</a>
                    <a class="dropdown-divider"></a>
                    <a class="dropdown-item" v-on:click.stop="typeSomething">Send stdin input</a>
                </div>
            </div>
        </div>
        <div class="dropdown is-hoverable">
            <div class="dropdown-trigger">
                <button class="button" aria-haspopups="true" aria-controls="dropdown-menu-page">
                    <span>Page</span>
                </button>
            </div>
            <div class="dropdown-menu" id="dropdown-menu-page" role="menu">
                <div class="dropdown-content">
                    <a class="dropdown-item" v-on:click.stop="insertPageBefore">Insert new page before</a>
                    <a class="dropdown-item" v-on:click.stop="insertPageAfter">Insert new page after</a>
                    <a class="dropdown-item" v-on:click.stop="deletePage">Delete page</a>
                    <a class="dropdown-divider"></a>
                    <a class="dropdown-item" v-on:click.stop="movePageBefore">Move page before</a>
                    <a class="dropdown-item" v-on:click.stop="movePageAfter">Move page after</a>
                </div>
            </div>
        </div>
        <div class="dropdown is-hoverable">
            <div class="dropdown-trigger">
                <button class="button" aria-haspopups="true" aria-controls="dropdown-menu-debug">
                    <span>Debug</span>
                </button>
            </div>
            <div class="dropdown-menu" id="dropdown-menu-debug" role="menu">
                <div class="dropdown-content">
                    <a class="dropdown-item" v-on:click.stop="debugDump">Console dump</a>
                </div>
            </div>    
        </div>
        <status
            v-bind:value="status"
        >

    </div>

    
<nav class="pagination" role="navigation" aria-label="pagination">
  <a class="pagination-previous" v-on:click="pagePrevious">Previous</a>
  <a class="pagination-next" v-on:click="pageNext">Next</a>
  <ul class="pagination-list">
    <li v-for="p in pagination">
      <a v-if="p !== -1" class="pagination-link" v-on:click="handlePage(p - 1)" v-bind:class="{ 'is-current': p === page + 1 }" :aria-label="p">{{p}}</a>
      <span v-if="p === -1" class="pagination-ellipsis">&hellip;</span>
    </li>
  </ul>
</nav>

    <cells
        v-on:update:value="handleInput"
        v-on:update:values="handleDrag"
        v-on:action="handleAction"
        v-on:click="handleClick"
        v-bind:values="cells"
        v-bind:select="selectCell"
        v-bind:command="command"
        ref="cells"
    >
    </cells>
</div>

<script type='module'>

import { onready } from './onready.js'
import { signalMap,
         isBusy,
         isStarting, setStarting,
         setInterrupt, clearInterrupt,
         inputPut
       } from './signal.js';
import { newPythonKernel } from './python.js';

// The event bus is for application events that bypass the component hierarchy.
// It is currently used to pass focus clicks from deep children back to toplevel.
// Tightly coupled events from child->parent are not put on the event bus.
const EventBus = new Vue();

onready(function() {

    // Global variable keeping list of all codemirror editors
    // Needed to quickly update dragdrop state (prevent dropping in editors)
    Vue.prototype.$globalCMList = [];

    Vue.component('status', {
        props: ['value'],
        template: String.raw`
            <div class="status">
                <p>{{ value }}</p>
            </div>`,
    });

    Vue.component('codemirror', {
        props: ['options', 'value', 'id'],
        template: String.raw`
            <div class="cellinput">
                <textarea></textarea>
            </div>`,
        mounted: function() {
            var self = this;
            var elem = self.$el.querySelector('textarea');
            self.editor = CodeMirror.fromTextArea(elem, self.options);
            self.$globalCMList.push(self.editor);
            self.editor.getWrapperElement().classList.add('cellinput');
            self.editor.setValue(self.value || '');
            self.editor.on('change', function(cm) {
                self.$emit('update:value', cm.getValue());
            });
            self.editor.on('focus', function(cm) {
                EventBus.$emit('cmfocus', { id:self.id });
            });
            self.editor.setOption('extraKeys', {
                // Remove default actions for commands handled at higher app level
                'Ctrl-Up': function(cm) {},
                'Ctrl-Down': function(cm) {},
                'Ctrl-Left': function(cm) {},
                'Ctrl-Right': function(cm) {},
                'Esc': function(cm) {},
                'Ctrl-Enter': function(cm) {},
                'Shift-Enter': function(cm) {},
                'Alt-Enter': function(cm) {},
                'Ctrl-C': function(cm) {},
                'Ctrl-K': function(cm) {},
                'Ctrl-I': function(cm) {},
            });
        },
        watch: {
            value: function(v) {
                var currentValue = this.editor.getValue();
                if (currentValue !== v) {
                    this.editor.setValue(v);
                }
            },
        },
        methods: {
            focus () {
                this.editor.focus();
                return true;
            },
            blur () {
                this.editor.getInputField().blur();
                return true;
            }
        }
    });

    Vue.component('dataoutput', {
        props: ['value', 'isResult'],
        template: String.raw`
            <div>
                <pre v-if="isPre(value)" :class="getClass(value)"><img v-if="isResult" src="../gfx/right2.svg" width=10 height=10></img> {{ value['text/plain'] }}</pre>
                <div v-if="isHtml(value)" :class="getClass(value)"><img v-if="isResult" src="../gfx/right2.svg" width=10 height=10></img><div class="content" v-html="value['text/html']"></div></div>
                <img v-if="isSVG(value)" :src="dataURI(value['image/svg+xml'])" />
            </div>
        `,
        methods: {
            getClass (value) {
                return "stdout";
            },
            isPre (value) {
                return value['text/plain'] !== undefined;
            },
            isHtml (value) {
                return value['text/html'] !== undefined;
            },
            isSVG (value) {
                return value['image/svg+xml'] !== undefined;
            },
            dataURI (value) {
                return 'data:image/svg+xml;base64,' + btoa(value);
            }
        }
    });

    Vue.component('celloutput', {
        props: ['values'],
        template: String.raw`
            <div class="output">
                <template v-for="value in values">
                    <pre v-if="isStream(value)" :class="value.name">{{ value.text }}</pre>
                    <dataoutput
                        v-if="isExecuteResult(value) || isDisplayData(value)"
                        v-bind:value="value.data"
                        v-bind:isResult="isExecuteResult(value)"
                    >
                    </dataoutput>
                </template>
            </div>`,
        methods: {
            isStream (value) {
                return value.output_type === 'stream';
            },
            isExecuteResult (value) {
                return value.output_type === 'execute_result';
            },
            isDisplayData (value) {
                return value.output_type === 'display_data';
            },
        }
    });

    Vue.component('cell', {
        props: ['value', 'output', 'id', 'selected', 'type', 'state', 'command'],
        template: String.raw`
            <div class="cell" v-bind:class="classObject" v-on:click.stop="handleClick">
                <div class="side-left handle" :class="leftClass">
                </div>
                <div class="side-right" :class="rightClass">
                    <codemirror
                        v-bind:value="value"
                        v-bind:id="id"
                        v-on:update:value="handleInput"
                        v-on:action="handleAction"
                        v-if="showEdit"
                        ref="codemirror"
                        >
                    </codemirror>
                    <celloutput
                        v-bind:values="filteredOutput"
                        v-if="showResults"
                    >
                    </celloutput>
                </div>
            </div>`,
        computed: {
            showEdit () {
                return this.type === 'code' || this.type === 'markdown-edit';
            },
            showResults () {
                return this.type === 'code' || this.type === 'markdown-view' || this.type === 'markdown-edit';
            },
            classObject: function () {
                return {
                    selected: this.selected,
                    command: this.command,
                    working: this.state === 'working',
                }
            },
            filteredOutput () {
                if (this.type === 'code') {
                    return this.output;
                }
                if (this.type === 'markdown-edit' || this.type === 'markdown-view') {
                    return [ {
                        output_type:'display_data',
                        data: {
                            'text/html': marked(this.value),
                        },
                    } ];
                }
            },
            leftClass: function() {
                return {
                    working: this.state === 'working',
                }
            },
            rightClass: function () {
                return {
                    code: this.type === 'code',
                    markdown: this.type === 'markdown-edit' || this.type === 'markdown-view',
                }
            },
        },
        methods: {
            handleInput (event) {
                this.$emit('update:value', { id:this.id, value:event });
            },
            handleAction (event) {
                this.$emit('action', { id:this.id, action:event.action });
            },
            handleClick (event) {
                this.$emit('click', { id:this.id });
            },
            focus () {
                if (this.$refs.codemirror) {
                    return this.$refs.codemirror.focus();
                } else {
                    return false;
                }
            },
            blur () {
                if (this.$refs.codemirror) {
                    return this.$refs.codemirror.blur();
                } else {
                    return false;
                }
            }

        }
    });

    Vue.component('draggable', vuedraggable);

    Vue.component('cells', {
        props: [ 'values', 'select', 'command' ],
        template: String.raw`
            <draggable
                class="cells"
                v-model='contents'
                handle=".handle"
                v-on:start="dragStart"
                v-on:end="dragEnd"
            >
                <cell
                    v-for="(content, index) in contents"
                    v-bind:value="content.source"
                    v-bind:output="content.outputs"
                    v-bind:id="index"
                    v-bind:key="content.id"
                    v-bind:selected="isSelected(index)"
                    v-bind:command="isSelected(index) && command"
                    v-bind:type="computeType(content)"
                    v-bind:state="content.state"
                    v-on:update:value="handleInput"
                    v-on:action="handleAction"
                    v-on:click="handleClick"
                    ref="cell"
                >
                </cell>
            </draggable>`,
        computed: {
            contents: {
                get() {
                    return this.values;
                },
                set(values) {
                    this.$emit('update:values', values);
                }
            }
        },
        methods: {
            computeType (content) {
                if (content.cell_type === 'code') return 'code';
                if (content.cell_type === 'markdown' && content.metadata !== undefined && content.metadata.subtype === 'view') return 'markdown-view';
                if (content.cell_type === 'markdown' && content.metadata !== undefined && content.metadata.subtype === 'edit') return 'markdown-edit';
                throw "Illegal content type";
            },
            isSelected (index) {
                return index === this.select;
            },
            dragStart (event) {
                const cm = this.$globalCMList;
                for (var i = 0; i < cm.length; i++) {
                    cm[i].__oldDragDrop = cm[i].getOption('dragDrop');
                    cm[i].setOption('dragDrop', false);
                }
            },
            dragEnd (event) {
                const cm = this.$globalCMList;
                for (var i = 0; i < cm.length; i++) {
                    cm[i].setOption('dragDrop', cm[i].__oldDragDrop);
                }
            },
            handleInput (event) {
                this.$emit('update:value', event);
            },
            handleAction (event) {
                this.$emit('action', event);
            },
            handleClick (event) {
                this.$emit('click', event);
            },
            focus (n) {
                return this.$refs.cell[n].focus();
            },
            blur (n) {
                return this.$refs.cell[n].blur();
            },
            blurAll () {
                for (let i = 0; i < this.values.length; i++) {
                    this.blur(i);
                }
                return true;
            }
        }
    });

    const opts = {
        onReady: function (version) {
            EventBus.$emit('update:status', 'Ready');
            console.log(version);
        },
    };
    var python = newPythonKernel(opts);

    function newCell() {
        return {
            cell_type: 'code',
            execution_count: 1,
            source: '',
            outputs: [],
            metadata: {}
        };
    }
    function newPage() {
        return [ newCell() ];
    }
    const store = new Vuex.Store({
        state: {
            cells: [newPage()],
            selectCell: 0,
            page: 0,
            state: '',
            mode: 'edit',
        },
        mutations: {
            newNotebook (state) {
                Vue.set(state, 'cells', [newPage()]);
                Vue.set(state, 'selectCell', 0);
                Vue.set(state, 'page', 0);
                Vue.set(state, 'mode', 'edit');
            },
            setSource (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'source', payload.source);
            },
            clearOutput (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'outputs', []);
            },
            addOutput (state, payload) {
                state.cells[payload.p][payload.n].outputs.push(payload.out);
            },
            setCellState (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'state', payload.state);
            },
            insertCellBefore (state, payload) {
                state.cells[payload.p].splice(payload.n, 0, newCell());
            },
            insertCellAfter (state, payload) {
                state.cells[payload.p].splice(payload.n + 1, 0, newCell());
            },
            insertPageBefore (state, payload) {
                state.cells.splice(payload.p, 0, newPage());
            },
            insertPageAfter (state, payload) {
                state.cells.splice(payload.p + 1, 0, newPage());
            },
            deletePage (state, payload) {
                state.cells.splice(payload.p, 1);
            },
            deleteCell (state, payload) {
                state.cells[payload.p].splice(payload.n, 1);
            },
            updateCells (state, payload) {
                Vue.set(state.cells, payload.p, payload.cells);
            },
            moveCell (state, payload) {
                const page = state.cells[payload.p];
                const cell = page[payload.n];
                page.splice(payload.n, 1); // remove cell
                page.splice(payload.position, 0, cell); // add original cell
            },
            movePage (state, payload) {
                const page = state.cells[payload.p];
                state.cells.splice(payload.p, 1); // remove page
                state.cells.splice(payload.position, 0, page); // add original page
            },
            cellType (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'cell_type', payload.type);
                if (payload.subtype !== undefined) {
                    if (state.cells[payload.p][payload.n].metadata === undefined) {
                        Vue.set(state.cells[payload.p][payload.n], 'metadata', {});
                    }
                    Vue.set(state.cells[payload.p][payload.n].metadata, 'subtype', payload.subtype);
                }
            },
            initialiseStore(state) {
                if (localStorage.getItem('store')) {
                    this.replaceState(
                        Object.assign(state, JSON.parse(localStorage.getItem('store')))
                    );
                }
            },
            setSelectCell(state, payload) {
                Vue.set(state, 'selectCell', payload);
            },
            setPage(state, payload) {
                Vue.set(state, 'selectCell', 0);
                Vue.set(state, 'page', payload);
            },
            setMode(state, payload) {
                if (payload === 'edit' || payload === 'command') {
                    Vue.set(state, 'mode', payload);
                }
            }
        }
    });

    // Subscribe to store updates
    store.subscribe(function (mutation, state) {
        localStorage.setItem('store', JSON.stringify(state));
    });

    function beep() {
        console.log('Beep (placeholder for visual effect)');
    }

    var app = new Vue({
        el: '#app',
        store,
        data: () => {
            return {
                opts: { lineNumbers: true },
                status: 'Initializing',
            };
        },
        beforeCreate() {
            this.$store.commit('initialiseStore');
        },
        mounted () {
            const self = this;
            self.modeEdit();
            self.updateFocus();
            EventBus.$on('cmfocus', function (event) {
                // If user clicks on CodeMirror edit area, switch to edit mode
                // Otherwise the cursor will focus and we'll still be in command mode
                // Note this also triggers when we tell CodeMirror to focus
                // Be careful not to get into infinite loops
                self.modeEdit();
            });
            EventBus.$on('update:status', function (payload) {
                self.status = payload;
            });
        },
        computed: {
            notebook() {
                return this.$store.state;
            },
            pagination() {
                const pages = this.countPages();
                // Simple case is not too many pages, just show them all in this case
                let prePages = 3;
                let postPages = 3;
                if (pages <= 2 + 2 + prePages + 1 + postPages) {
                    let result = [];
                    for (let i = 0; i < pages; i++) {
                        result.push(i + 1);
                    }
                    return result;
                }
                const page = this.page + 1;
                var result = [];
                result.push(1);
                var start = page - prePages;
                if (start <= 3) {
                    // If there is not enough room for first ellipsis,
                    // put pages in that spot instead.
                    postPages += 3 - start;
                    start = 3;
                }
                if (start >= 3) {
                    // If we would just put ... but the page would do as nicely, put the page
                    if (start == 3) {
                        result.push(2);
                    } else {
                        result.push(-1);
                    }
                }
                var end = page + postPages;
                if (end >= pages - 1) {
                    start -= end - (pages - 1) + 1;
                    end = pages - 2;
                }
                for (var i = start; i <= end; i++) {
                    result.push(i);
                }
                if (end <= pages - 2) {
                    if (end == pages - 2) {
                        result.push(pages - 1);
                    } else {
                        result.push(-1);
                    }
                }
                result.push(pages);
                return result;
            },
            page () {
                return this.$store.state.page;
            },
            selectCell () {
                return this.$store.state.selectCell;
            },
            cells () {
                return this.$store.state.cells[this.page];
            },
            mode () {
                return this.$store.state.mode;
            },
            command () {
                return this.$store.state.mode === 'command';
            }
        },
        methods: {
            ifCommand (func) {
                var self = this;
                if (self.mode === 'command') {
                    return func();
                }
            },
            ifEdit (func) {
                var self = this;
                if (self.mode === 'edit') {
                    return func();
                }
            },
            modeCommand () {
                if (this.mode !== 'command') {
                    this.$store.commit('setMode', 'command');
                    this.updateFocus();
                }
            },
            modeEdit () {
                if (this.mode !== 'edit') {
                    this.$store.commit('setMode', 'edit');
                    this.updateFocus();
                }
            },
            updateFocus() {
                // Look at selectCell, call focus() on that codemirror instance
                // Wait until DOM updates in case we're adding new cells or rearranging editors
                this.$nextTick( () => {
                    const n = this.selectCell;
                    this.$refs.cells.blurAll();
                    this.$el.focus();
                    if (this.mode === 'edit') {
                        if (n !== undefined) {
                           this.$refs.cells.focus(n);
                        }
                    }
                });
            },
            handleInput (event) {
                this.$store.commit('setSource', {p:this.page, n:event.id, source:event.value});
            },
            clearOutput (p, n) {
                this.$store.commit('clearOutput', {p, n});
            },
            setCellState (p, n, state) {
                this.$store.commit('setCellState', {p, n, state});
            },
            cellType (p, n)
            {
                return this.$store.state.cells[p][n].cell_type;
            },
            internalEval (p, n) {
                this.clearOutput(p, n);
                if (this.cellType(p, n) !== 'code') {
                    beep();
                    return;
                }
                this.setCellState(p, n, 'working');
                EventBus.$emit('update:status', 'Working');
                const self = this;
                python.evaluate(this.$store.state.cells[p][n].source, {
                    onStdout: function(msg) {
                        self.addOutput(p, n, { 
                            output_type: 'stream',
                            name: 'stdout',
                            text: msg
                        });
                    },
                    onStderr: function(msg) {
                        self.addOutput(p, n, { 
                            output_type: 'stream',
                            name: 'stderr',
                            text: msg
                        });
                    },
                    onResponse: function(content_type, msg) {
                        // Adding -> things is handled by run_cell and exec
                        // This could change styling to show eval is done TODO
                        self.setCellState(p, n, '');
                        EventBus.$emit('update:status', 'Ready');
                    },
                    onOutput: function(content_type, msg) {
                        if (content_type === 'text/html') {
                            self.addOutput(p, n, {
                                output_type: 'display_data',
                                data: {
                                    "text/html": msg
                                }
                            });
                        } else if (content_type === 'text/plain') {
                            self.addOutput(p, n, {
                                output_type: 'display_data',
                                data: {
                                    "text/plain": msg
                                }
                            });
                        } else if (content_type === 'image/svg+xml') {
                            self.addOutput(p, n, {
                                output_type: 'display_data',
                                data: {
                                    "image/svg+xml": msg
                                }
                            });
                        } else if (content_type === 'image/png') {
                            console.log('PNG data ', msg);
                            // TODO... make it show up
                        } else {
                            console.log('Unknown content_type ' + content_type);
                        }
                    },
                });

            },
            eval () {
                const p = this.page;
                const n = this.selectCell;
                if (!isBusy() && !isStarting()) {
                    clearInterrupt();
                    this.internalEval(p, n);
                } else {
                    beep();
                }
            },
            evalNext () {
                const p = this.page;
                const n = this.selectCell;
                if (!isBusy() && !isStarting()) {
                    clearInterrupt();
                    this.internalEval(p, n);
                    this.cellNext();
                } else {
                    beep();
                }
            },
            evalNew () {
                const p = this.page;
                const n = this.selectCell;
                if (!isBusy() && !isStarting()) {
                    clearInterrupt();
                    this.internalEval(p, n);
                    this.insertCellAfter();
                } else {
                    beep();
                }
            },
            interrupt () {
                console.log('Interrupting python');
                EventBus.$emit('update:status', 'Interrupt');
                setInterrupt();
            },
            terminate () {
                console.log('Terminating python');
                EventBus.$emit('update:status', 'Initializing');
                python.terminate();
            },
            handleAction (event) {
                const p = this.page;
                const n = event.id;
                var action = event.action;
                if (action === 'insert-cell-after') {
                    this.insertCellAfter(event);
                } else {
                    console.log("Unknown action", action, event.id);
                }
            },
            handleDrag (event) {
                const p = this.page;
                this.$store.commit('updateCells', { p, cells:event });
                this.$store.commit('setSelectCell', undefined);
            },
            handlePage (page) {
                this.$store.commit('setPage', page);
                this.$store.commit('setSelectCell', 0);
                this.updateFocus();
            },
            addOutput (p, n, out) {
                this.$store.commit('addOutput', {p, n, out});
            },
            handleClick (event) {
                this.$store.commit('setSelectCell', event.id);
            },
            handleOuterClick (event) {
                // This is getting triggered by clicking page buttons, so ignore for now
                //this.$store.commit('setSelectCell', undefined);
            },
            cellPrevious (event) {
                if (this.selectCell > 0) {
                    this.$store.commit('setSelectCell', this.selectCell - 1);
                    this.updateFocus();
                }
            },
            cellNext (event) {
                if (this.selectCell < this.cells.length - 1) {
                    this.$store.commit('setSelectCell', this.selectCell + 1);
                    this.updateFocus();
                }
            },
            fileNew (event) {
                this.$store.commit('newNotebook');
                this.updateFocus();
            },
            fileSave (event) {
                const data = JSON.stringify(this.$store.state);
                const blob = new Blob([data], {type:"application/json"});
                const url = window.URL.createObjectURL(blob);
                console.log("saving", url);
            },
            selectionValid (n) {
                if (n === undefined) {
                    return false;
                }
                return (n >= 0 && n < this.$store.state.cells[this.page].length);
            },
            countPages () {
                return this.$store.state.cells.length;
            },
            pageValid (n) {
                return n >= 0 && n < this.countPages();
            },
            deleteCell (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('deleteCell', { p, n });
                    if (n === this.$store.state.cells[p].length) {
                        // If last cell deleted, select new last one
                        this.$store.commit('setSelectCell', n - 1)
                    }
                    if (this.$store.state.cells[p].length === 0) {
                        // If user deleted last cell, delete page
                        this.deletePage();
                    }
                }
                this.updateFocus();
            },
            deletePage (event) {
                const p = this.page;
                this.$store.commit('deletePage', { p });
                this.$store.commit('setSelectCell', 0);
                if (this.page >= this.$store.state.cells.length) {
                    // If we deleted the last page, move to new last page
                    this.$store.commit('setPage', this.$store.state.cells.length - 1);
                }
                if (this.$store.state.cells.length === 0) {
                    // If user deleted last page, start with fresh notebook
                    this.$store.commit('newNotebook');
                }
                this.updateFocus();
            },
            typeSomething (event) {
                var txt = window.prompt('Enter input');
                for (var i = 0; i < txt.length; i++) {
                    inputPut(txt.charCodeAt(i));
                }
                // Add newline
                inputPut(10);
                // Signal no more input
                inputPut(0);
            },
            insertCellBefore (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('insertCellBefore', { p, n });
                    this.$store.commit('setSelectCell', n);
                    this.updateFocus();
                }
            },
            insertCellAfter (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('insertCellAfter', { p, n });
                    this.$store.commit('setSelectCell', n + 1);
                    this.updateFocus();
                }
            },
            insertPageBefore (event) {
                const p = this.page;
                if (this.pageValid(p)) {
                    this.$store.commit('insertPageBefore', { p });
                    this.$store.commit('setSelectCell', 0);
                    this.updateFocus();
                }
            },
            insertPageAfter (event) {
                const p = this.page;
                if (this.pageValid(p)) {
                    this.$store.commit('insertPageAfter', { p });
                    this.$store.commit('setSelectCell', 0);
                    this.updateFocus();
                }
            },
            typeCellCode (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'code' });
                }
            },
            typeCellMarkdownEdit (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'markdown', subtype:'edit' });
                }
            },
            typeCellMarkdownView (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'markdown', subtype:'view' });
                }
            },
            debugDump (event) {
                console.log('Notebook dump');
                console.log(JSON.stringify(this.notebook, null, 2));
            },
            moveCellBefore (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && n > 0) {
                    this.$store.commit('moveCell', { p, n, position:n - 1 });
                    this.$store.commit('setSelectCell', n - 1);
                    this.updateFocus();
                }
            },
            moveCellAfter (event) {
                const p = this.page;
                const n = this.$store.state.selectCell;
                if (this.pageValid(p) && n < this.$store.state.cells[p].length - 1) {
                    this.$store.commit('moveCell', { p, n, position:n + 1 });
                    this.$store.commit('setSelectCell', n + 1);
                    this.updateFocus();
                }
            },
            movePageBefore (event) {
                const p = this.page;
                if (p > 0) {
                    this.$store.commit('movePage', { p:p, position:p - 1 });
                    this.$store.commit('setPage', p - 1);
                    this.updateFocus();
                }
            },
            movePageAfter (event) {
                const p = this.page;
                if (p < this.$store.state.cells.length - 1) {
                    this.$store.commit('movePage', { p:p, position:p + 1 });
                    this.$store.commit('setPage', p + 1);
                    this.updateFocus();
                }
            },
            pagePrevious (event) {
                const p = this.page;
                if (p > 0) {
                    this.$store.commit('setPage', p - 1);
                    this.$store.commit('setSelectCell', 0);
                    this.updateFocus();
                }
            },
            pageNext (event) {
                const p = this.page;
                if (p < this.$store.state.cells.length - 1) {
                    this.$store.commit('setPage', p + 1);
                    this.$store.commit('setSelectCell', 0);
                    this.updateFocus();
                }
            },
            handleKeyup (event) {
                console.log('Keyup', event);
            },
        }
    });

    window.app = app;

});


</script>
</body>
</html>
