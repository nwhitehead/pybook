<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>PyBook Notebook</title>
<script defer src="../lib/codemirror/codemirror.js"></script>
<link rel="stylesheet" href="../lib/codemirror/codemirror.css">
<script defer src="../lib/codemirror/python.js"></script>
<script defer src="../lib/codemirror/markdown.js"></script>
<link rel="stylesheet" href="../lib/bulma.min.css">

<style>

</style>
</head>
<body>

<div id="app" tabindex="0"
    v-on:click.stop="handleOuterClick"
    v-on:keyup.right.ctrl.exact="pageNext"
    v-on:keyup.left.ctrl.exact="pagePrevious"
    v-on:keyup.up.ctrl.exact="cellPrevious"
    v-on:keyup.down.ctrl.exact="cellNext"
    v-on:keyup.esc.exact="ifEdit(modeCommand)"
    v-on:keyup.enter.exact="ifCommand(modeEdit)"
    v-on:keyup.enter.ctrl.exact="eval"
    v-on:keyup.enter.shift.exact="evalNext"
    v-on:keyup.enter.alt.exact="evalNew"
    v-on:keyup.c.ctrl.exact='interrupt'
    v-on:keyup.k.ctrl.exact='terminate'
    v-on:keyup.i.ctrl.exact='insertCellAfter'
    v-on:keyup.up.exact='ifCommand(cellPrevious)'
    v-on:keyup.down.exact='ifCommand(cellNext)'
    v-on:keyup.a.exact='ifCommand(insertCellBefore)'
    v-on:keyup.b.exact='ifCommand(insertCellAfter)'
    v-on:keyup.c.exact='ifCommand(clearCellOutput)'
    v-on:keyup.d.exact='ifCommand(deleteCell)'
    v-on:keyup.h.exact='ifCommand(toggleHiddenCell)'
    v-on:keyup.r.exact='ifCommand(toggleReadOnlyCell)'
    v-on:keyup.s.exact='ifCommand(toggleSubmitCell)'
    v-on:keyup.y.exact='ifCommand(typeCellCode)'
    v-on:keyup.m.exact='ifCommand(typeCellMarkdownEdit)'
    v-on:keyup.m.shift.exact='ifCommand(typeCellMarkdownView)'
    v-on:keyup.k.exact='ifCommand(typeCellCheckpointSave)'
    v-on:keyup.k.shift.exact='ifCommand(typeCellCheckpointUse)'
    v-on:keyup.a.alt.exact='switchDocId'
>

        <div class="uibox">
            <div id="menu">
                <dropdown name="Cell" :values="[
                    { text:'Insert new cell before', action:insertCellBefore },
                    { text:'Insert new cell after', action:insertCellAfter },
                    { text:'Delete cell', action:deleteCell },
                    { divider:true },
                    { text:'Move cell up', action:moveCellBefore },
                    { text:'Move cell down', action:moveCellAfter },
                    { divider:true },
                    { text:'Type - Code', action:typeCellCode },
                    { text:'Type - MarkDown - Edit', action:typeCellMarkdownEdit },
                    { text:'Type - MarkDown - View', action:typeCellMarkdownView },
                    { divider:true },
                    { text:'Send stdin input', action:typeSomething },
                ]">
                </dropdown>
                <dropdown name="Page" :values="[
                    { text:'Insert new page before', action:insertPageBefore },
                    { text:'Insert new page after', action:insertPageAfter },
                    { text:'Delete page', action:deletePage },
                    { divider:true },
                    { text:'Move page earlier', action:movePageBefore },
                    { text:'Move page later', action:movePageAfter },
                ]">
                </dropdown>
                <dropdown name="Debug" :values="[
                    { text:'Console dump', action:debugDump },
                    { text:'Clear local files', action:debugClear },
                    { text:'Save notebook', action:debugSave },
                    { divider:true },
                    { text:'Save', filesave:true },
                ]">
                </dropdown>
                <Status
                    v-bind:value="status"
                ></Status>
            </div>

            <pagination
                v-bind:pages="countPages()"
                v-bind:current="page"
                v-on:page="handlePage"
                v-on:page-previous="pagePrevious"
                v-on:page-next="pageNext"
            >
            </pagination>
        </div>

            <cells
                v-on:update:value="handleInput"
                v-on:update:values="handleDrag"
                v-on:action="handleAction"
                v-on:click="handleClick"
                v-on:submit="handleSubmit"
                v-bind:values="cells"
                v-bind:select="selectCell"
                v-bind:command="isCommandMode"
                ref="cells"
            >
            </cells>
</div>

<footer class="footer">
    <div class="content has-text-centered">
    </div>
</footer>

<script type='module'>

import { onready } from './onready.js'
import { signalMap,
         isBusy,
         isStarting, setStarting,
         setInterrupt, clearInterrupt,
         inputPut
       } from './signal.js';
import { newPythonKernel } from './python.js';
import { parse,
         unparse } from './parser.js';

import Status from './components/Status.vue';
import Pagination from './components/Pagination.vue';



onready(function() {

    Vue.component('filesave', {
        props: ['value'],
        template: String.raw`
            <div class="filesave">
                <a class="dropdown-item" v-on:click.stop="action">Save</a>
            </div>`,
        methods: {
            action() {
                let a = document.createElement('a');
                const data = unparse(this.value.cells);
                const blob = new Blob([data], {type:"text/plain"});
                const url = window.URL.createObjectURL(blob);
                a.download = 'intro.pbnb';
                a.href = url;
                a.click();
            }

        }
    });
    Vue.component('fileimport', {
        props: [],
        template: String.raw`
            <div class="fileimport">
                <span>File import</span>
                <input id="filebutton" type="file" ref="select" @change="readFile()" />
            </div>`,
        methods: {
            readFile() {
                const self = this;
                this.file = this.$refs.select.files[0];
                const reader = new FileReader();
                reader.onload = (res) => {
                    console.log('-----------BEGIN NOTEBOOK TEXT---------------');
                    console.log(res.target.result);
                    console.log('-----------END NOTEBOOK TEXT-----------------');
                    const parsed = parse(res.target.result);
                    console.log('-----------BEGIN NOTEBOOK---------------');
                    console.log(parsed);
                    console.log('-----------END NOTEBOOK-----------------');
                    self.$emit('load', parsed);
                };
                reader.onerror = (err) => console.log(err);
                reader.readAsText(this.file);
            }
        }
    });


    Vue.component('celloutput', {
        props: ['values'],
        template: String.raw`
            <div class="output">
                <template v-for="value in values">
                    <pre v-if="isStream(value)" :class="value.name">{{ value.text }}</pre>
                    <dataoutput
                        v-if="isExecuteResult(value) || isDisplayData(value)"
                        v-bind:value="value.data"
                        v-bind:isResult="isExecuteResult(value)"
                    >
                    </dataoutput>
                </template>
            </div>`,
        methods: {
            isStream (value) {
                return value.output_type === 'stream';
            },
            isExecuteResult (value) {
                return value.output_type === 'execute_result';
            },
            isDisplayData (value) {
                return value.output_type === 'display_data';
            },
        }
    });

    Vue.component('checkpoint', {
        props: ['value', 'type'],
        template: String.raw`
            <div class="tags are-medium has-addons">
                <span :class="checkpointClassLeft">{{ checkpointText() }}</span>
                <span :class="checkpointClassMiddle">{{ value }}</span>
            </div>`,
        computed: {
            checkpointClassLeft () {
                return {
                    'tag': true,
                    'is-primary': this.type === 'save',
                    'is-link': this.type === 'use',
                }
            },
            checkpointClassMiddle () {
                return {
                    'tag': true,
                }
            },
        },
        methods: {
            checkpointText: function() {
                if (this.type === 'save') return 'Save';
                if (this.type === 'use') return 'From';
                throw "Illegal checkpoint type";
            },
        }
    });

    Vue.component('cell', {
        props: ['value', 'output', 'id', 'selected', 'type', 'subtype', 'state', 'command', 'hidden', 'readonly', 'submit'],
        template: String.raw`
            <div class="cell" v-bind:class="classObject" v-on:click.stop="handleClick" v-if="!hidden">
                <div class="side-left handle" :class="leftClass">
                </div>
                <div class="side-right" :class="rightClass">
                    <div :class="readonlyClass" v-if="showEdit">
                        <codemirror
                            v-bind:value="value"
                            v-bind:id="id"
                            v-bind:options="cmOptions"
                            v-on:update:value="handleInput"
                            v-on:action="handleAction"
                            ref="codemirror"
                        >
                        </codemirror>
                    </div>
                    <checkpoint
                        v-bind:value="value"
                        v-bind:type="subtype"
                        v-if="showCheckpoint"
                    >
                    </checkpoint>
                    <button class="button is-primary" v-if="submit" v-on:click.stop="handleSubmit">
                        Submit
                    </button>
                    <celloutput
                        v-bind:values="filteredOutput"
                        v-if="showResults"
                    >
                    </celloutput>
                </div>
            </div>`,
        computed: {
            cmOptions () {
                let options = { };
                if (this.type === 'code') {
                    options.mode = 'python';
                }
                if (this.type === 'markdown') {
                    options.mode = 'markdown';
                }
                options.readOnly = this.readonly;
                return options;
            },
            showEdit () {
                return this.type === 'code' || (this.type === 'markdown' && this.subtype === 'edit');
            },
            showResults () {
                return this.type === 'code' || this.type === 'markdown';
            },
            showCheckpoint () {
                return this.type === 'checkpoint';
            },
            readonlyClass: function () {
                return {
                    'readonly-inner': this.readonly,
                };
            },
            classObject: function () {
                return {
                    selected: this.selected,
                    command: this.command,
                    working: this.state === 'working',
                    evaluated: this.state === 'evaluated',
                    readonly: this.readonly,
                }
            },
            filteredOutput () {
                if (this.type === 'code') {
                    return this.output;
                }
                if (this.type === 'markdown') {
                    return [ {
                        output_type:'display_data',
                        data: {
                            'text/html': marked(this.value),
                        },
                    } ];
                }
            },
            leftClass: function() {
                return {
                    working: this.state === 'working',
                    evaluated: this.state === 'evaluated',
                }
            },
            rightClass: function () {
                return {
                    code: this.type === 'code',
                    markdown: this.type === 'markdown',
                }
            },
        },
        methods: {
            handleInput (event) {
                this.$emit('update:value', { id:this.id, value:event });
            },
            handleAction (event) {
                this.$emit('action', { id:this.id, action:event.action });
            },
            handleClick (event) {
                this.$emit('click', { id:this.id });
            },
            handleSubmit (event) {
                this.$emit('submit', { id:this.id });
            },
            focus () {
                if (this.$refs.codemirror) {
                    return this.$refs.codemirror.focus();
                } else {
                    return false;
                }
            },
            blur () {
                if (this.$refs.codemirror) {
                    return this.$refs.codemirror.blur();
                } else {
                    return false;
                }
            }

        }
    });

    Vue.component('draggable', vuedraggable);

    Vue.component('cells', {
        props: [ 'values', 'select', 'command' ],
        template: String.raw`
            <draggable
                class="cells"
                v-model='contents'
                handle=".handle"
                v-on:start="dragStart"
                v-on:end="dragEnd"
            >
                <cell
                    v-for="(content, index) in contents"
                    v-bind:value="content.source"
                    v-bind:output="content.outputs"
                    v-bind:id="index"
                    v-bind:key="content.id"
                    v-bind:selected="isSelected(index)"
                    v-bind:command="isSelected(index) && command"
                    v-bind:type="computeType(content)"
                    v-bind:subtype="computeSubtype(content)"
                    v-bind:state="content.state"
                    v-bind:hidden="isHidden(content)"
                    v-bind:readonly="isReadOnly(content)"
                    v-bind:submit="isSubmit(content)"
                    v-on:update:value="handleInput"
                    v-on:action="handleAction"
                    v-on:click="handleClick"
                    v-on:submit="handleSubmit"
                    ref="cell"
                >
                </cell>
            </draggable>`,
        computed: {
            contents: {
                get() {
                    return this.values;
                },
                set(values) {
                    this.$emit('update:values', values);
                }
            }
        },
        methods: {
            isSubmit (content) {
                if (content.cell_type === 'code' && content.metadata !== undefined && content.metadata.submit === true) {
                    return true;
                }
                return false;
            },
            isHidden (content) {
                if (content.cell_type === 'code' && content.metadata !== undefined && content.metadata.hidden === true) {
                    return true;
                }
                return false;
            },
            isReadOnly (content) {
                if (content.metadata !== undefined && content.metadata.readonly === true) {
                    return true;
                }
                return false;
            },
            computeType (content) {
                if (content.cell_type === 'code') return 'code';
                if (content.cell_type === 'markdown') return 'markdown';
                if (content.cell_type === 'checkpoint') return 'checkpoint';
                throw "Illegal content type";
            },
            computeSubtype (content) {
                if (content.cell_type === 'code') return '';
                if (content.cell_type === 'markdown' && content.metadata !== undefined && content.metadata.subtype === 'view') return 'view';
                if (content.cell_type === 'markdown' && content.metadata !== undefined && content.metadata.subtype === 'edit') return 'edit';
                if (content.cell_type === 'checkpoint' && content.metadata !== undefined && content.metadata.subtype === 'save') return 'save';
                if (content.cell_type === 'checkpoint' && content.metadata !== undefined && content.metadata.subtype === 'use') return 'use';
                throw "Illegal content subtype";

            },
            isSelected (index) {
                return index === this.select;
            },
            dragStart (event) {
                const cm = this.$globalCMList;
                for (var i = 0; i < cm.length; i++) {
                    cm[i].__oldDragDrop = cm[i].getOption('dragDrop');
                    cm[i].setOption('dragDrop', false);
                }
            },
            dragEnd (event) {
                const cm = this.$globalCMList;
                for (var i = 0; i < cm.length; i++) {
                    cm[i].setOption('dragDrop', cm[i].__oldDragDrop);
                }
            },
            handleInput (event) {
                this.$emit('update:value', event);
            },
            handleAction (event) {
                this.$emit('action', event);
            },
            handleClick (event) {
                this.$emit('click', event);
            },
            handleSubmit (event) {
                this.$emit('submit', event);
            },
            focus (n) {
                return this.$refs.cell[n].focus();
            },
            blur (n) {
                return this.$refs.cell[n].blur();
            },
            blurAll () {
                // Check that this.values is defined
                // It can be undefined when all pages are deleted before fresh empty page is added
                if (this.values !== undefined) {
                    for (let i = 0; i < this.values.length; i++) {
                        this.blur(i);
                    }
                }
                return true;
            }
        }
    });

    let globalId = 0;
    function freshName() {
        const name = 'State ' + globalId;
        globalId++;
        return name;
    }

    const baseInitialState = 'Initial state';

    const opts = {
        onReady: function (version) {
            console.log(version);
            python.freshstate(baseInitialState, {
                onResponse: function() {
                    EventBus.$emit('update:status', 'Ready');
                },
            });
        },
    };
    var python = newPythonKernel(opts);

    function newCell() {
        return {
            cell_type: 'code',
            source: '',
            evalstate: '',
            outputs: [],
            metadata: {}
        };
    }
    function newPage() {
        return [ newCell() ];
    }
    const store = new Vuex.Store({
        state: {
            cells: [newPage()],
        },
        mutations: {
            newNotebook (state) {
                Vue.set(state, 'cells', [newPage()]);
            },
            setSource (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'source', payload.source);
            },
            clearOutput (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'outputs', []);
            },
            addOutput (state, payload) {
                state.cells[payload.p][payload.n].outputs.push(payload.out);
            },
            setCellState (state, payload) {
                const value = payload.state;
                if (value !== '' && value !== 'working' && value !== 'evaluated') {
                    throw "Illegal cell state";
                }
                Vue.set(state.cells[payload.p][payload.n], 'state', payload.state);
            },
            setCellEvalState (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'evalstate', payload.evalstate);
            },
            insertCellBefore (state, payload) {
                state.cells[payload.p].splice(payload.n, 0, newCell());
            },
            insertCellAfter (state, payload) {
                state.cells[payload.p].splice(payload.n + 1, 0, newCell());
            },
            insertPageBefore (state, payload) {
                state.cells.splice(payload.p, 0, newPage());
            },
            insertPageAfter (state, payload) {
                state.cells.splice(payload.p + 1, 0, newPage());
            },
            deletePage (state, payload) {
                state.cells.splice(payload.p, 1);
            },
            deleteCell (state, payload) {
                state.cells[payload.p].splice(payload.n, 1);
            },
            updateCells (state, payload) {
                Vue.set(state.cells, payload.p, payload.cells);
            },
            moveCell (state, payload) {
                const page = state.cells[payload.p];
                const cell = page[payload.n];
                page.splice(payload.n, 1); // remove cell
                page.splice(payload.position, 0, cell); // add original cell
            },
            movePage (state, payload) {
                const page = state.cells[payload.p];
                state.cells.splice(payload.p, 1); // remove page
                state.cells.splice(payload.position, 0, page); // add original page
            },
            cellSetFlag (state, payload) {
                // payload has:
                //   p: page
                //   n: cell num
                //   flag: flag name  (in 'hidden', 'readonly')
                //   value: true or false
                Vue.set(state.cells[payload.p][payload.n].metadata, payload.flag, payload.value);
            },
            cellType (state, payload) {
                Vue.set(state.cells[payload.p][payload.n], 'cell_type', payload.type);
                if (payload.subtype !== undefined) {
                    Vue.set(state.cells[payload.p][payload.n].metadata, 'subtype', payload.subtype);
                }
            },
            initializeObject (state, payload) {
                this.replaceState(Object.assign(state, payload));
            },
            initializeString (state, payload) {
                const parsed = JSON.parse(payload);
                this.commit('initializeObject', parsed);
            },
            initializeStore (state, payload) {
                const stored = localStorage.getItem(payload);
                if (stored) {
                    this.commit('initializeString', stored);
                }
                // Otherwise do nothing if no localStorage result
            }
        }
    });

    function beep() {
        console.log('Beep (placeholder for visual effect)');
    }

    var app = new Vue({
        el: '#app',
        store,
        data: () => {
            return {
                opts: { lineNumbers: true },
                status: 'Initializing',
                mode: 'edit',
                docId: 'pb001',
                selectCell: 0,
                page: 0,
            };
        },
        created() {
            // Subscribe to store updates
            const self = this;
            this.$store.subscribe(function (mutation, state) {
                localStorage.setItem(self.docId, JSON.stringify(state));
            });
            this.initializeStore();
        },
        mounted () {
            const self = this;
            self.modeEdit();
            self.updateFocus();
            EventBus.$on('cmfocus', function (event) {
                // If user clicks on CodeMirror edit area, switch to edit mode
                // Otherwise the cursor will focus and we'll still be in command mode
                // Note this also triggers when we tell CodeMirror to focus
                // Be careful not to get into infinite loops
                self.modeEdit();
            });
            EventBus.$on('update:status', function (payload) {
                self.status = payload;
            });
        },
        computed: {
            notebook() {
                let result = this.$store.state;
                result.opts = this.opts;
                // Do not include status
                result.mode = this.mode;
                result.selectCell = this.selectCell;
                result.page = this.page;
                return result;
            },
            cells () {
                return this.$store.state.cells[this.page];
            },
            isCommandMode () {
                return this.mode === 'command';
            }
        },
        methods: {
            initializeStore () {
                // Initialize store to localstorage value if it exists
                this.$store.commit('initializeStore', this.docId);
                // Clear evaluations, rename bad checkpoints and things
                this.sanitize();
            },
            freshNameNotebook () {
                // Find a fresh name that is never used for any state
                let names = {};
                // Build up dictionary of all names used for checkpoint states
                const numPages = this.$store.state.cells.length;
                for (let p = 0; p < numPages; p++) {
                    const numCells = this.$store.state.cells[p].length;
                    for (let n = 0; n < numCells; n++) {
                        const cellType = this.cellType(p, n);
                        const code = this.$store.state.cells[p][n].source;
                        const state = this.cellEvalState(p, n);
                        if (cellType === 'checkpoint') {
                            names[code] = true;
                        } else if (cellType === 'code' && state) {
                            names[state] = true;
                        }
                    }
                }
                // Keep trying numbered states until we have one that is not used
                let i = 0;
                while (true) {
                    const name = 'State ' + i;
                    if (!names[name]) {
                        break;
                    }
                }
                return name;
            },
            sanitize () {
                // Clear evaluates on load
                // Make sure checkpoint-use come after checkpoint-save
                let checkpoints = {}; // set of checkpoints seen
                const numPages = this.$store.state.cells.length;
                for (let p = 0; p < numPages; p++) {
                    const numCells = this.$store.state.cells[p].length;
                    for (let n = 0; n < numCells; n++) {
                        const cellType = this.cellType(p, n);
                        const subType = this.cellSubtype(p, n);
                        const code = this.$store.state.cells[p][n].source;
                        // Clear the eval state information (when loaded we have no active states)
                        this.setCellEvalState(p, n, undefined);
                        this.setCellState(p, n, '');
                        // If we hit a "checkpoint-use" verify it was defined previously
                        if (cellType === 'checkpoint' && subType === 'use') {
                            if (!checkpoints[code]) {
                                console.log("Notebook has checkpoint use before save for: [" + code + "]");
                                console.log("Setting checkpoint to [Initial state]");
                            }
                            this.$store.commit('setSource', {p, n, source:'Initial state'});
                        }
                        if (cellType === 'checkpoint' && subType === 'save') {
                            if (checkpoints[code]) {
                                console.log("Notebook already has checkpoint saved for: [" + code + "]");
                                const newState = this.freshNameNotebook();
                                console.log("Setting checkpoing to [" + newState + "]");

                            }
                            // Remember the name of this checkpoint
                            checkpoints[code] = true;
                        }
                    }
                }
            },
            switchDocId () {
                this.docId = 'pb002';
                this.initializeStore();
            },
            ifCommand (func) {
                var self = this;
                if (self.mode === 'command') {
                    return func();
                }
            },
            ifEdit (func) {
                var self = this;
                if (self.mode === 'edit') {
                    return func();
                }
            },
            modeCommand () {
                if (this.mode !== 'command') {
                    this.mode = 'command';
                    this.updateFocus();
                }
            },
            modeEdit () {
                if (this.mode !== 'edit') {
                    this.mode = 'edit';
                    this.updateFocus();
                }
            },
            updateFocus() {
                // Look at selectCell, call focus() on that codemirror instance
                // Wait until DOM updates in case we're adding new cells or rearranging editors
                this.$nextTick( () => {
                    const n = this.selectCell;
                    this.$refs.cells.blurAll();
                    this.$el.focus();
                    if (this.mode === 'edit') {
                        if (n !== undefined) {
                            this.$refs.cells.focus(n);
                        }
                    }
                });
            },
            handleInput (event) {
                this.$store.commit('setSource', {p:this.page, n:event.id, source:event.value});
            },
            handleLoad (event) {
                // We get parsed object that represents cells, but not other editor state
                // Fill in other editor state with sensible values.
                const state = { cells:event, mode:"edit", page:0, selectCell:0 };
                this.$store.commit('initializeObject', state);
            },
            clearOutput (p, n) {
                this.$store.commit('clearOutput', {p, n});
            },
            setCellState (p, n, state) {
                // The cell state is a string indicating:
                //   working        Currently being evaluated, has evalState (but it's not done)
                //   evaluated      Previously evaluated, shown as evaluated, has evalState
                //   ""             Not evaluated (no evalState)
                this.$store.commit('setCellState', {p, n, state});
            },
            setCellEvalState (p, n, evalstate) {
                // Set the tag indicating which python state was used to evaluate this cell (undefined if invalid)
                this.$store.commit('setCellEvalState', {p, n, evalstate});
            },
            cellType (p, n) {
                return this.$store.state.cells[p][n].cell_type;
            },
            cellSubtype (p, n) {
                const metadata = this.$store.state.cells[p][n].metadata;
                if (metadata === undefined) {
                    return metadata;
                }
                return metadata.subtype;
            },
            cellState (p, n) {
                return this.$store.state.cells[p][n].state;
            },
            cellEvalState (p, n) {
                return this.$store.state.cells[p][n].evalState;
            },
            metadata (p, n) {
                return this.$store.state.cells[p][n].metadata;
            },
            isSubmit (p, n) {
                const mdata = this.metadata(p, n);
                return mdata && mdata.submit === true;
            },
            isHidden (p, n) {
                const mdata = this.metadata(p, n);
                return mdata && mdata.hidden === true;
            },
            isReadOnly (p, n) {
                const mdata = this.metadata(p, n);
                return mdata && mdata.readonly === true;
            },
            internalEval (p, n, submit) {
                // Evaluate a single cell (no cursor movement)
                this.clearOutput(p, n);
                if (this.cellType(p, n) !== 'code') {
                    beep();
                    return;
                }
                this.setCellState(p, n, 'working');
                EventBus.$emit('update:status', 'Working');
                const self = this;
                function done() {
                    // Adding -> things is handled by run_cell and exec
                    self.setCellState(p, n, ''); // evaluated once we get linear history line working
                    EventBus.$emit('update:status', 'Ready');
                }
                const code = this.$store.state.cells[p][n].source;
                this.baseCodeEval(p, n, code, false, baseInitialState, done);
            },
            invalidateCell (p, n) {
                // Just set the given state to invalid evaluation and erase state
                // (No logic in invalidating other parts of notebook)
                this.setCellState(p, n, '');
                this.setCellEvalState(p, n, undefined);
            },
            invalidateAt (p, n) {
                // Invalidate one cell, doing logic for consequences
                this.invalidateCell(p, n);
                const cellType = this.cellType(p, n);
                const subType = this.cellSubtype(p, n);
                if (cellType === 'checkpoint' && subType === 'save') {
                    // If we invalidate a save, then do global invalidation of everywhere that uses it
                    const code = this.$store.state.cells[p][i].source;
                    this.invalidateStateUse(code);
                }
                // All types need to invalidate after the cell
                this.invalidateAfter(p, n);
            },
            invalidateStateUse (state) {
                // Invalidate all cells that depend on using a state
                const numPages = this.$store.state.cells.length;
                for (let p = 0; p < numPages; p++) {
                    const numCells = this.$store.state.cells[p].length;
                    for (let n = 0; n < numCells; n++) {
                        const cellType = this.cellType(p, n);
                        const subType = this.cellSubtype(p, n);
                        const code = this.$store.state.cells[p][n].source;
                        // If we hit a "checkpoint-use" that matches then invalidate
                        if (cellType === 'checkpoint' && subType === 'use' && code === state) {
                            this.invalidateCell(p, n);
                            // Also do linear invalidation from cells after the use
                            // They also depend on the checkpoint-use results
                            this.invalidateAfter(p, n);
                            continue;
                        }
                    }
                }
                
            },
            invalidateAfter (p, n) {
                // Invalidate linear state after position p, n
                // Note that each page restarts state, so this only affects current page
                const numCells = this.$store.state.cells[p].length;
                for (let i = n + 1; i < numCells; i++) {
                    const cellType = this.cellType(p, i);
                    const subType = this.cellSubtype(p, i);
                    // If we hit a "checkpoint-use" then stop invalidating, we're done
                    if (cellType === 'checkpoint' && subType === 'use') {
                        break;
                    }
                    // If we hit a "checkpoint-save" then invalidate all uses of that state anywhere
                    if (cellType === 'checkpoint' && subType === 'save') {
                        this.invalidateCell(p, i);
                        const code = this.$store.state.cells[p][i].source;
                        this.invalidateStateUse(code);
                        // Keep going after the save in our invalidation
                        continue;
                    }
                    this.invalidateCell(p, i);
                }
            },
            linearEval (p, n) {
                // NOT WORKING YET
                // Evaluate a single cell (no cursor movement)
                const cellType = this.cellType(p, n);
                const subType = this.cellSubtype(p, n);
                const code = this.$store.state.cells[p][n].source;
                if (cellType === 'checkpoint' && subType === 'use') {
                    // Can always evaluate a checkpoint-use, don't need previous cell to be evaluated
                    this.clearOutput(p, n);
                    this.invalidateAt(p, n);
                    const newState = freshName();
                    const that = this;
                    this.setCellState(p, n, 'working');
                    EventBus.$emit('update:status', 'Working');
                    python.duplicatestate(code, newState, {
                        onResponse: function () {
                            that.setCellState(p, n, 'evaluated');
                            that.setCellEvalState(p, n, newState);
                            console.log('duplicated use state', code, newState);
                            EventBus.$emit('update:status', 'Ready');
                        },
                    });
                    return;
                }
                if (cellType === 'checkpoint' && subType === 'save') {
                    this.invalidateAt(p, n);
                    // Can evaluate a save if the previous cell was evaluated
                    if (n == 0) {
                        console.log('Trying to save starting state??'); // TODO could make this work
                        return;
                    }
                    const previousState = this.cellState(p, n - 1);
                    if (previousState !== 'evaluated') {
                        console.log('Previous cell not evaluated');
                        return;
                    }
                    const state = this.cellEvalState(p, n - 1);
                    // OK, can save it
                    this.clearOutput(p, n);
                    this.setCellState(p, n, 'working');
                    EventBus.$emit('update:status', 'Working');
                    const that = this;
                    python.duplicatestate(state, code, {
                        onResponse: function () {
                            that.setCellState(p, n, 'evaluated');
                            that.setCellEvalState(p, n, state);
                            console.log('duplicated use state', state, code);
                            EventBus.$emit('update:status', 'Ready');
                        },
                    });
                    return;
                }
                    // Can always evaluate a checkpoint-use, don't need previous cell to be evaluated
                if (this.cellType(p, n) !== 'code') {
                    // Can always "evaluate" things that are not code
                    return;
                }
                this.invalidateAt(p, n);
///************************************************************
                // Here is what we do once we have a concrete state to use
                const self = this;
                function doEval (state) {
                    self.setCellState(p, n, 'working');
                    EventBus.$emit('update:status', 'Working');
                    function done() {
                        self.setCellState(p, n, 'evaluated');
                        EventBus.$emit('update:status', 'Ready');
                    }
                    self.baseCodeEval(p, n, code, false, state, done);
                }
                if (n === 0) {
                    // First cell is like a checkpoint-use "Initial state"
                    // Need to duplicate 'Initial state' then pass result to doEval continuation
                }
                if (n > 0) {
                    const previousState = this.cellState(p, n - 1);
                    if (previousState !== 'evaluated') {
                        console.log('Previous cell not evaluated');
                        return;
                    }
                    state = this.cellEvalState(p, n - 1);
                }
            },
            baseCodeEval (p, n, code, submit, state, done) {
                // This function does not do any UI, just evaluates one cell
                // Needs position of cell for writing output
                // Calls done callback when eval is finished
                const self = this;
                const callbacks = {
                    onStdout: function(msg) {
                        self.addOutput(p, n, { 
                            output_type: 'stream',
                            name: 'stdout',
                            text: msg
                        });
                    },
                    onStderr: function(msg) {
                        self.addOutput(p, n, { 
                            output_type: 'stream',
                            name: 'stderr',
                            text: msg
                        });
                    },
                    onResponse: function() {
                        return done();
                    },
                    onOutput: function(content_type, msg) {
                        if (content_type === 'text/html') {
                            self.addOutput(p, n, {
                                output_type: 'display_data',
                                data: {
                                    "text/html": msg
                                }
                            });
                        } else if (content_type === 'text/plain') {
                            self.addOutput(p, n, {
                                output_type: 'display_data',
                                data: {
                                    "text/plain": msg
                                }
                            });
                        } else if (content_type === 'image/svg+xml') {
                            self.addOutput(p, n, {
                                output_type: 'display_data',
                                data: {
                                    "image/svg+xml": msg
                                }
                            });
                        } else if (content_type === 'image/png') {
                            console.log('PNG data ', msg);
                            // TODO... make it show up
                        } else {
                            console.log('Unknown content_type ' + content_type);
                        }
                    },
                };
                if (submit) {
                    python.submit(code, state, callbacks);
                } else {
                    python.evaluate(code, state, callbacks);
                }
            },
            eval () {
                const p = this.page;
                const n = this.selectCell;
                if (!isBusy() && !isStarting()) {
                    clearInterrupt();
                    this.internalEval(p, n);
                } else {
                    beep();
                }
            },
            evalNext () {
                const p = this.page;
                const n = this.selectCell;
                if (!isBusy() && !isStarting()) {
                    clearInterrupt();
                    this.internalEval(p, n);
                    this.cellNext();
                } else {
                    beep();
                }
            },
            evalNew () {
                const p = this.page;
                const n = this.selectCell;
                if (!isBusy() && !isStarting()) {
                    clearInterrupt();
                    this.internalEval(p, n);
                    this.insertCellAfter();
                } else {
                    beep();
                }
            },
            interrupt () {
                console.log('Interrupting python');
                EventBus.$emit('update:status', 'Interrupt');
                setInterrupt();
            },
            terminate () {
                console.log('Terminating python');
                EventBus.$emit('update:status', 'Initializing');
                python.terminate();
            },
            handleAction (event) {
                const p = this.page;
                const n = event.id;
                var action = event.action;
                if (action === 'insert-cell-after') {
                    this.insertCellAfter(event);
                } else {
                    console.log("Unknown action", action, event.id);
                }
            },
            handleDrag (event) {
                const p = this.page;
                this.$store.commit('updateCells', { p, cells:event });
                this.selectCell = undefined;
            },
            handlePage (page) {
                this.page = page;
                this.selectCell = 0;
                this.updateFocus();
            },
            addOutput (p, n, out) {
                this.$store.commit('addOutput', {p, n, out});
            },
            handleClick (event) {
                this.selectCell = event.id;
            },
            handleOuterClick (event) {
                // This is getting triggered by clicking page buttons, so ignore for now
            },
            handleSubmit (event) {
                console.log('app handling submit');
                const p = this.page;
                const n = event.id;
                if (!isBusy() && !isStarting()) {
                    clearInterrupt();
                    this.internalEval(p, n, true);
                } else {
                    beep();
                }
            },
            cellPrevious (event) {
                let c = this.selectCell - 1;
                // Skip hidden cells (but don't go off page)
                while (c >= 0 && this.isHidden(this.page, c)) {
                    c--;
                }
                if (c >= 0 && !this.isHidden(this.page, c)) {
                    this.selectCell = c;
                    this.updateFocus();
                }
            },
            cellNext (event) {
                let c = this.selectCell + 1;
                // Skip hidden cells (but don't go off page)
                while (c < this.cells.length - 1 && this.isHidden(this.page, c)) {
                    c++;
                }
                if (c < this.cells.length && !this.isHidden(this.page, c)) {
                    this.selectCell = c;
                    this.updateFocus();
                }
            },
            fileNew (event) {
                this.$store.commit('newNotebook');
                this.mode = 'edit';
                this.selectCell = 0;
                this.updateFocus();
            },
            selectionValid (n) {
                if (n === undefined) {
                    return false;
                }
                return (n >= 0 && n < this.$store.state.cells[this.page].length);
            },
            countPages () {
                return this.$store.state.cells.length;
            },
            pageValid (n) {
                return n >= 0 && n < this.countPages();
            },
            deleteCell (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('deleteCell', { p, n });
                    if (n === this.$store.state.cells[p].length) {
                        // If last cell deleted, select new last one
                        this.selectCell = n - 1;
                    }
                    if (this.$store.state.cells[p].length === 0) {
                        // If user deleted last cell, delete page
                        this.deletePage();
                    }
                }
                this.updateFocus();
            },
            deletePage (event) {
                const p = this.page;
                this.$store.commit('deletePage', { p });
                this.selectCell = 0;
                if (this.page >= this.$store.state.cells.length) {
                    // If we deleted the last page, move to new last page
                    this.page = this.$store.state.cells.length - 1;
                }
                if (this.$store.state.cells.length === 0) {
                    // If user deleted last page, start with fresh notebook
                    this.$store.commit('newNotebook');
                    this.page = 0;
                }
                this.updateFocus();
            },
            typeSomething (event) {
                var txt = window.prompt('Enter input');
                for (var i = 0; i < txt.length; i++) {
                    inputPut(txt.charCodeAt(i));
                }
                // Add newline
                inputPut(10);
                // Signal no more input
                inputPut(0);
            },
            clearCellOutput (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.clearOutput(p, n);
                }
            },
            insertCellBefore (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('insertCellBefore', { p, n });
                    this.selectCell = n;
                    this.updateFocus();
                }
            },
            insertCellAfter (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('insertCellAfter', { p, n });
                    this.selectCell = n + 1;
                    this.updateFocus();
                }
            },
            insertPageBefore (event) {
                const p = this.page;
                if (this.pageValid(p)) {
                    this.$store.commit('insertPageBefore', { p });
                    this.selectCell = 0;
                    this.updateFocus();
                }
            },
            insertPageAfter (event) {
                const p = this.page;
                if (this.pageValid(p)) {
                    this.$store.commit('insertPageAfter', { p });
                    this.selectCell = 0;
                    this.updateFocus();
                }
            },
            typeCellCode (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'code' });
                }
            },
            typeCellMarkdownEdit (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'markdown', subtype:'edit' });
                }
            },
            typeCellMarkdownView (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'markdown', subtype:'view' });
                }
            },
            typeCellCheckpointSave (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'checkpoint', subtype:'save' });
                }
            },
            typeCellCheckpointUse (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    this.$store.commit('cellType', { p, n, type:'checkpoint', subtype:'use' });
                }
            },
            toggleSubmitCell (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    const submit = this.isSubmit(p, n);
                    this.$store.commit('cellSetFlag', { p, n, flag:'submit', value:!submit });
                }
            },
            toggleReadOnlyCell (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    const readonly = this.isReadOnly(p, n);
                    this.$store.commit('cellSetFlag', { p, n, flag:'readonly', value:!readonly });
                }
            },
            toggleHiddenCell (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && this.selectionValid(n)) {
                    const hidden = this.isHidden(p, n);
                    this.$store.commit('cellSetFlag', { p, n, flag:'hidden', value:!hidden });
                }
            },
            debugDump (event) {
                console.log('Notebook dump');
                console.log(JSON.stringify(this.notebook, null, 2));
            },
            debugClear (event) {
                localStorage.clear();
                this.fileNew();
                this.initializeStore();
            },
            debugSave (event) {
                console.log('Notebook save to file');
                // const txt = '<a href="data:application/xml;charset=utf-8," download="filename.html">Save</a>';
                // const data = JSON.stringify(this.$store.state);
                // const blob = new Blob([data], {type:"application/json"});
                // const url = window.URL.createObjectURL(blob);
                // console.log("saving", url);
            },
            moveCellBefore (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && n > 0) {
                    this.$store.commit('moveCell', { p, n, position:n - 1 });
                    this.selectCell = n - 1;
                    this.updateFocus();
                }
            },
            moveCellAfter (event) {
                const p = this.page;
                const n = this.selectCell;
                if (this.pageValid(p) && n < this.$store.state.cells[p].length - 1) {
                    this.$store.commit('moveCell', { p, n, position:n + 1 });
                    this.selectCell = n + 1;
                    this.updateFocus();
                }
            },
            movePageBefore (event) {
                const p = this.page;
                if (p > 0) {
                    this.$store.commit('movePage', { p:p, position:p - 1 });
                    this.page = p - 1;
                    this.updateFocus();
                }
            },
            movePageAfter (event) {
                const p = this.page;
                if (p < this.$store.state.cells.length - 1) {
                    this.$store.commit('movePage', { p:p, position:p + 1 });
                    this.page = p + 1;
                    this.updateFocus();
                }
            },
            pagePrevious (event) {
                const p = this.page;
                if (p > 0) {
                    this.page = p - 1;
                    this.selectCell = 0;
                    this.updateFocus();
                }
            },
            pageNext (event) {
                const p = this.page;
                if (p < this.$store.state.cells.length - 1) {
                    this.page = p + 1;
                    this.selectCell = 0;
                    this.updateFocus();
                }
            },
        }
    });

    window.app = app;

});


</script>
</body>
</html>
